{"meta":{"version":1,"warehouse":"4.0.0"},"models":{"Asset":[{"_id":"themes/maupassant/source/css/copycode.css","path":"css/copycode.css","modified":0,"renderable":1},{"_id":"themes/maupassant/source/css/copyright.css","path":"css/copyright.css","modified":0,"renderable":1},{"_id":"themes/maupassant/source/css/donate.css","path":"css/donate.css","modified":0,"renderable":1},{"_id":"themes/maupassant/source/css/search.css","path":"css/search.css","modified":0,"renderable":1},{"_id":"themes/maupassant/source/css/style.scss","path":"css/style.scss","modified":0,"renderable":1},{"_id":"themes/maupassant/source/js/codeblock-resizer.js","path":"js/codeblock-resizer.js","modified":0,"renderable":1},{"_id":"themes/maupassant/source/js/copycode.js","path":"js/copycode.js","modified":0,"renderable":1},{"_id":"themes/maupassant/source/js/copyright.js","path":"js/copyright.js","modified":0,"renderable":1},{"_id":"themes/maupassant/source/js/donate.js","path":"js/donate.js","modified":0,"renderable":1},{"_id":"themes/maupassant/source/js/fancybox.js","path":"js/fancybox.js","modified":0,"renderable":1},{"_id":"themes/maupassant/source/js/love.js","path":"js/love.js","modified":0,"renderable":1},{"_id":"themes/maupassant/source/js/search.js","path":"js/search.js","modified":0,"renderable":1},{"_id":"themes/maupassant/source/js/share.js","path":"js/share.js","modified":0,"renderable":1},{"_id":"themes/maupassant/source/js/smartresize.js","path":"js/smartresize.js","modified":0,"renderable":1},{"_id":"themes/maupassant/source/js/totop.js","path":"js/totop.js","modified":0,"renderable":1},{"_id":"themes/maupassant/source/img/alipay.svg","path":"img/alipay.svg","modified":0,"renderable":1},{"_id":"themes/maupassant/source/img/bitcoin.svg","path":"img/bitcoin.svg","modified":0,"renderable":1},{"_id":"themes/maupassant/source/img/github.svg","path":"img/github.svg","modified":0,"renderable":1},{"_id":"themes/maupassant/source/img/like.svg","path":"img/like.svg","modified":0,"renderable":1},{"_id":"themes/maupassant/source/img/paypal.svg","path":"img/paypal.svg","modified":0,"renderable":1},{"_id":"themes/maupassant/source/img/wechat.svg","path":"img/wechat.svg","modified":0,"renderable":1},{"_id":"source/favicon.ico","path":"favicon.ico","modified":0,"renderable":0}],"Cache":[{"_id":"source/_posts/hello-world.md","hash":"7d98d6592de80fdcd2949bd7401cec12afd98cdf","modified":499162500000},{"_id":"themes/maupassant/_config.yml","hash":"d79415153b522e37c025b8521e8e68a24f12b035","modified":1645255123248},{"_id":"themes/maupassant/.gitignore","hash":"d7d27e5a9bcffe7f90dc2f4f0752e19020e40f40","modified":1645197889022},{"_id":"themes/maupassant/package.json","hash":"5328c4c435cd4a5fe47caae31b9975013cdca5bb","modified":1645197889051},{"_id":"themes/maupassant/LICENSE","hash":"0663fd3a7ea9fc4f4c634b4d73e2da426b536f86","modified":1645197889023},{"_id":"themes/maupassant/README.md","hash":"f7f36a633be735f2d9f5c2746cc6b440eb60e03c","modified":1645197889024},{"_id":"themes/maupassant/.travis.yml","hash":"f8da426b97088e4caa5226cff219a5d95087961f","modified":1645197889022},{"_id":"themes/maupassant/languages/en.yml","hash":"93674c5df281d7f5647fe500e10924008d8017c6","modified":1645197889027},{"_id":"themes/maupassant/languages/de-DE.yml","hash":"25d1d8cd8113045a7603c14af1ea1539fc6456ed","modified":1645197889026},{"_id":"themes/maupassant/languages/es-ES.yml","hash":"3cc9312fbdba4a8f8e8254804121e4724c719bcc","modified":1645197889027},{"_id":"themes/maupassant/languages/fr-FR.yml","hash":"3a50568f200b9c1258415b53727e42c6b6c7ea0b","modified":1645197889028},{"_id":"themes/maupassant/languages/ko.yml","hash":"a454bcec60113507bc1d593a699849822386c196","modified":1645197889028},{"_id":"themes/maupassant/languages/ru.yml","hash":"36edc014c6aaef367d58929089bf7915375e71a6","modified":1645197889030},{"_id":"themes/maupassant/languages/zh-CN.yml","hash":"a6fa4ea6c3a59ae6ac13230d6154d1fdd6c149f3","modified":1645197889030},{"_id":"themes/maupassant/languages/zh-TW.yml","hash":"795f420382a150d570a06ffc278c4e7819260691","modified":1645197889031},{"_id":"themes/maupassant/layout/base-without-sidebar.pug","hash":"00792d30c4197ee79049060f56308327888e6812","modified":1645197889046},{"_id":"themes/maupassant/layout/archive.pug","hash":"3770284e425fb0c14d60ae6ac454f58ba07ce76b","modified":1645197889045},{"_id":"themes/maupassant/layout/base.pug","hash":"4c380e48f7e84619e2fc311dac82fc0e0e017c46","modified":1645197889047},{"_id":"themes/maupassant/layout/index.pug","hash":"089fc4f6fa928c4229cd79d8dd38b7cb6155d8a5","modified":1645197889047},{"_id":"themes/maupassant/layout/page.pug","hash":"647bfba2208cbef052e1bf307d30a6775671215d","modified":1645197889048},{"_id":"themes/maupassant/layout/post.pug","hash":"0f5f124b944a64493d4b0b997c1eebfe8dd4f891","modified":1645197889048},{"_id":"themes/maupassant/layout/single-column.pug","hash":"8b4b731cdf86379d526821a1fa950bf15ed61f15","modified":1645197889049},{"_id":"themes/maupassant/layout/tagcloud.pug","hash":"9ad3083c2f70fdb460ecbe277be97320a2621196","modified":1645197889050},{"_id":"themes/maupassant/layout/timeline.pug","hash":"04f7efdc45acda1faff409d0f80fa5a0dd2309d0","modified":1645197889050},{"_id":"themes/maupassant/layout/_partial/footer.pug","hash":"92aa15e813bfb411803cc54218feb5410469a9c2","modified":1645197889034},{"_id":"themes/maupassant/layout/_partial/after_footer.pug","hash":"7f9f9d33edc563651222c0dd9ade7f38d4600f7c","modified":1645197889033},{"_id":"themes/maupassant/layout/_partial/darkmode.pug","hash":"8a4c53229394ba6cf63afd427b4e6b1dc1156526","modified":1645197889034},{"_id":"themes/maupassant/layout/_partial/helpers.pug","hash":"9e44f6d32f2449b4109c33118f8285fa2fc7b023","modified":1645197889036},{"_id":"themes/maupassant/layout/_partial/comments.pug","hash":"063e74bd7b98f9df098aa213e69379effb53122e","modified":1645197889033},{"_id":"themes/maupassant/layout/_partial/head.pug","hash":"69541492efa4367040f925698f565bf5a535afae","modified":1645197889035},{"_id":"themes/maupassant/layout/_partial/mathjax.pug","hash":"ac6e3a92bf18ab6bbd0e041b6796b295bae963ee","modified":1645197889037},{"_id":"themes/maupassant/layout/_partial/paginator.pug","hash":"03ad0c49ae6f8a999ae35b38d08e25775f51f52a","modified":1645197889038},{"_id":"themes/maupassant/layout/_partial/mathjax2.pug","hash":"234a792e64ba208fa97d2f99772ece23056a53ec","modified":1645197889037},{"_id":"themes/maupassant/layout/_partial/post_nav.pug","hash":"b11d9e6000449838b17f508429f29ffb60f53096","modified":1645197889038},{"_id":"themes/maupassant/layout/_partial/tag.pug","hash":"a255fca3557a0dac0ad49c7d4456133420c22bd8","modified":1645197889039},{"_id":"themes/maupassant/layout/_partial/totop.pug","hash":"eb91a3baf9411188c7c8130f63a674f541ca9c81","modified":1645197889039},{"_id":"themes/maupassant/layout/_partial/wordcount.pug","hash":"f848b6ac3f44cfd4110a2d1c742c73eacd6285ee","modified":1645197889040},{"_id":"themes/maupassant/layout/_widget/category.pug","hash":"7707b4c718a935882ee986d0bb0078e50cdbea64","modified":1645197889040},{"_id":"themes/maupassant/layout/_widget/copyright.pug","hash":"44935b31e7b3b6232a9a587775cfe9e90efc6a89","modified":1645197889041},{"_id":"themes/maupassant/layout/_widget/links.pug","hash":"7bc7c17cfd498c3e0c3371cef78f08f1dc25db36","modified":1645197889043},{"_id":"themes/maupassant/layout/_widget/donate.pug","hash":"666a89edbc1d7186afba68e0b3bee7e957d7a26e","modified":1645197889042},{"_id":"themes/maupassant/layout/_widget/recent_comments.pug","hash":"757f517b776178e50ae4d3b8af129a3d80240d05","modified":1645197889043},{"_id":"themes/maupassant/layout/_widget/search.pug","hash":"6aa743486f282545f553a4fad6aae037afe26108","modified":1645197889044},{"_id":"themes/maupassant/layout/_widget/recent_posts.pug","hash":"770b6c41cbf7969ed33adf87eec3be6f50a0911b","modified":1645197889044},{"_id":"themes/maupassant/layout/_widget/tag.pug","hash":"37f236365b153fc40324391e5a602d6d50014e18","modified":1645197889044},{"_id":"themes/maupassant/source/css/copycode.css","hash":"23fefb18f1d4dc7bde33e29d6ae737570277d943","modified":1645197889052},{"_id":"themes/maupassant/source/css/copyright.css","hash":"ad420043e1d0518bfbf3b2a2d87fb5b104587c6f","modified":1645197889052},{"_id":"themes/maupassant/source/css/search.css","hash":"a1720a63170ff4ae9048f634e8e1900e7a3cc45a","modified":1645197889054},{"_id":"themes/maupassant/source/css/donate.css","hash":"d9ef1520e136198c0ae13acef7da22a275fb4dbf","modified":1645197889053},{"_id":"themes/maupassant/source/css/style.scss","hash":"1f62641d42446fd00ad0e62cc5dd2b38811ab89e","modified":1645197889055},{"_id":"themes/maupassant/source/js/codeblock-resizer.js","hash":"c77270e684a60babc1abb7353e700ecdc5a66d30","modified":1645197889060},{"_id":"themes/maupassant/source/js/copycode.js","hash":"6df3139581744e7bcd47243e4587f5397c2a24c3","modified":1645197889061},{"_id":"themes/maupassant/source/js/copyright.js","hash":"0e9a845ae05d2f00721ff6ee910c8c3cace26043","modified":1645197889062},{"_id":"themes/maupassant/source/js/donate.js","hash":"82f06bd69782c1138c98b4276771a41e3a54c061","modified":1645197889062},{"_id":"themes/maupassant/source/js/fancybox.js","hash":"8a993c1c4ad40789d2960b682cb2130382a0f26a","modified":1645197889063},{"_id":"themes/maupassant/source/js/love.js","hash":"60df5dc3d09c8f33d1d02f54cbc73bf8d62f52fb","modified":1645197889063},{"_id":"themes/maupassant/source/js/search.js","hash":"65d8e6d6c46fa060ce5b0d89e2fd778b6b2967d5","modified":1645197889064},{"_id":"themes/maupassant/source/js/share.js","hash":"514e726c1efae9f6566600fa0e945b4b9e620f2e","modified":1645197889065},{"_id":"themes/maupassant/source/js/totop.js","hash":"15de186b089c245fe60766d509b587919f05ff23","modified":1645197889066},{"_id":"themes/maupassant/source/js/smartresize.js","hash":"150ab1cad40d7ae081b0896b13f7d7cbac4e6338","modified":1645197889065},{"_id":"themes/maupassant/source/img/alipay.svg","hash":"3d94d2f9b09e352802628c9225578e1086f5fef3","modified":1645197889056},{"_id":"themes/maupassant/source/img/github.svg","hash":"277798d16cb6106e45ef74f6b9972011fa43401b","modified":1645197889057},{"_id":"themes/maupassant/source/img/bitcoin.svg","hash":"590b6b6462896168d08b30dfe2de5f08950d5553","modified":1645197889057},{"_id":"themes/maupassant/source/img/paypal.svg","hash":"09786c983a10bc570dcd05b87cec601e9d01eb00","modified":1645197889059},{"_id":"themes/maupassant/source/img/like.svg","hash":"e6e4bd1af076be9358316cac89efdc22ef4a5064","modified":1645197889058},{"_id":"themes/maupassant/source/img/wechat.svg","hash":"19c1f68ec8c0b8e9f7855e7a6e78077f70a1aedc","modified":1645197889060},{"_id":"source/_posts/page.md","hash":"6779281424255f1685030f2f4f218dad5c3a5930","modified":1645199978659},{"_id":"public/2022/02/18/page/index.html","hash":"4fa98f8c2745e3189e902906450ce2fedd8eef22","modified":1645200004737},{"_id":"public/archives/index.html","hash":"a207b3f943d5b72902bbb656a988efc34963e007","modified":1645369255932},{"_id":"public/2022/02/18/hello-world/index.html","hash":"bccc31f1596501aad507f904ef5f04098c1881fa","modified":1645200004737},{"_id":"public/archives/2022/02/index.html","hash":"97e5060ae7a6eadfc76bec0fe15d02a1accfe028","modified":1645369255932},{"_id":"public/archives/2022/index.html","hash":"97e5060ae7a6eadfc76bec0fe15d02a1accfe028","modified":1645369255932},{"_id":"public/index.html","hash":"5c173940a4cf8cdd0e797da55f4fc0d71b35ab8d","modified":1645369255932},{"_id":"public/img/alipay.svg","hash":"3d94d2f9b09e352802628c9225578e1086f5fef3","modified":1645342999884},{"_id":"public/img/bitcoin.svg","hash":"590b6b6462896168d08b30dfe2de5f08950d5553","modified":1645342999884},{"_id":"public/img/github.svg","hash":"277798d16cb6106e45ef74f6b9972011fa43401b","modified":1645342999884},{"_id":"public/img/like.svg","hash":"e6e4bd1af076be9358316cac89efdc22ef4a5064","modified":1645342999884},{"_id":"public/img/paypal.svg","hash":"09786c983a10bc570dcd05b87cec601e9d01eb00","modified":1645342999884},{"_id":"public/img/wechat.svg","hash":"19c1f68ec8c0b8e9f7855e7a6e78077f70a1aedc","modified":1645342999884},{"_id":"public/css/copycode.css","hash":"e2463b8dacf629e180a1b6cd80667ca8044292eb","modified":1645342999884},{"_id":"public/css/donate.css","hash":"95b2fd65042afecc0b5530847c369bcc11d74bd0","modified":1645342999884},{"_id":"public/css/copyright.css","hash":"a418da11a88d1feb14500df42ed97a64da6a7611","modified":1645342999884},{"_id":"public/js/copyright.js","hash":"7b1bd775ea22abf33d57f78628f436bf656e439a","modified":1645342999884},{"_id":"public/js/donate.js","hash":"bdddd8d9847462d020f7a511e7e12c046223195d","modified":1645342999884},{"_id":"public/css/search.css","hash":"9406e138d7bb6a9ef4a067eba1dafa627519c8a7","modified":1645342999884},{"_id":"public/js/copycode.js","hash":"fde1f153bab1f00ae8930668094c00aa9ff3c7a3","modified":1645342999884},{"_id":"public/js/fancybox.js","hash":"13c4781570339f4fba76a3d7f202e442817dd605","modified":1645342999884},{"_id":"public/js/codeblock-resizer.js","hash":"5d0b786d60bf225d9eabcc9cece2719ff4d9b6cd","modified":1645342999884},{"_id":"public/js/love.js","hash":"5cf89f622bf891cf1986845eb92eadef6f358eb7","modified":1645342999884},{"_id":"public/js/share.js","hash":"a2f9de374523dc7f2ddb90ed5f24b668c20d9272","modified":1645342999884},{"_id":"public/js/search.js","hash":"6fdfd143646d12b8dbef9b5809cea768192f08aa","modified":1645342999884},{"_id":"public/js/smartresize.js","hash":"3ef157fd877167e3290f42c67a624ea375a46c24","modified":1645342999884},{"_id":"public/js/totop.js","hash":"7dbf8fcf582a4fb6eb9b2c60d6de9f9c2091ec4c","modified":1645342999884},{"_id":"public/css/style.css","hash":"a9be1af00cdbd2d164fdf67c75db3c752c1dea4a","modified":1645342999884},{"_id":"source/_imgs/compilation_assembly.png","hash":"f8837a880e98315c0fda6d0fbab20601f3bcacac","modified":1645208464015},{"_id":"source/_posts/selenium/selenium.md","hash":"033e18431846389f60d8bc48088b82ef397b1b56","modified":1645209205017},{"_id":"source/_posts/test.md","hash":"46f2be64f95a1e205ae99a695f5aa7745212a348","modified":1645209588495},{"_id":"source/_posts/android_reverse_analytics/android_reverse_analytics.md","hash":"7867c26fdf2f336972dafea3e0ed1a92fa58ecce","modified":1645209308469},{"_id":"source/_posts/hexo/hexo.md","hash":"068db9df4f9d0db42a4f39918cd271a42c159d35","modified":1645209012043},{"_id":"source/_posts/computer_network_basics/computer_network_basics copy.md","hash":"c5dba167881709e5b9c2a9c670099d3a38c036fb","modified":1645209052223},{"_id":"source/_posts/linux_command/linux_command.md","hash":"091058a309fb0985de53223d050d64fe32c8c298","modified":1645209024717},{"_id":"source/_posts/android_reverse_analytics/compilation_assembly.png","hash":"f8837a880e98315c0fda6d0fbab20601f3bcacac","modified":1645209104614},{"_id":"source/_posts/test/compilation_assembly.png","hash":"f8837a880e98315c0fda6d0fbab20601f3bcacac","modified":1645209104614},{"_id":"public/2022/02/19/test/index.html","hash":"a50cb59b09bdf66eb125ab25d93f607d2bf2645d","modified":1645209559250},{"_id":"public/2020/04/28/linux_command/linux_command/index.html","hash":"7f857622ac7e0b43cf7a344ce12d043119c18132","modified":1645209729700},{"_id":"public/2020/04/28/computer_network_basics/computer_network_basics copy/index.html","hash":"df26046a4098f41e05584116d2092af9d7c883ba","modified":1645209729700},{"_id":"public/2020/04/24/android_reverse_analytics/android_reverse_analytics/index.html","hash":"ce882c4e0bebe155d1ca94c8576491199a8b654b","modified":1645209708095},{"_id":"public/2020/04/24/selenium/selenium/index.html","hash":"da7351daa3e1c583b90145f904e587391e1f3f71","modified":1645209729700},{"_id":"public/2018/11/07/hexo/hexo/index.html","hash":"d3ba94468a3952aa68c2b0b66f902f752c32a023","modified":1645209729700},{"_id":"public/archives/2018/index.html","hash":"ede440aaca4d65899b78911de893d47a65cdcbed","modified":1645369255932},{"_id":"public/archives/2018/11/index.html","hash":"ede440aaca4d65899b78911de893d47a65cdcbed","modified":1645369255932},{"_id":"public/archives/2020/index.html","hash":"230b9847a324418358d44535b96d0654c5a8be36","modified":1645369255932},{"_id":"public/archives/2020/04/index.html","hash":"230b9847a324418358d44535b96d0654c5a8be36","modified":1645369255932},{"_id":"public/categories/Android/index.html","hash":"fcc63409e2bd2799fea3809c0e26c92722d2c6b1","modified":1645369255932},{"_id":"public/tags/Blog/index.html","hash":"60bbd5c5be13b268d8829d89227766225f2fb7bd","modified":1645369255932},{"_id":"public/tags/Computer-Network/index.html","hash":"fb06e61e48b5c1aca1a3682675d9409d227e7c48","modified":1645369255932},{"_id":"public/tags/Linux/index.html","hash":"1c1f39044f5bcdee3c206c67581dd3d1e70341a0","modified":1645369255932},{"_id":"public/tags/Test/index.html","hash":"8fe4937fb312222ac6fa59629a61af4bd1f04921","modified":1645211817864},{"_id":"public/tags/Security/index.html","hash":"c870ef77e1e64d7a5be0b3bbc32cc491c22a72c9","modified":1645369255932},{"_id":"public/2022/02/19/test/compilation_assembly.png","hash":"f8837a880e98315c0fda6d0fbab20601f3bcacac","modified":1645209559250},{"_id":"source/_posts/android_reverse_analytics.md","hash":"c1ad650f1ca7f2a1ab23451c67d35bb9d48708e9","modified":1645253217915},{"_id":"public/2020/04/24/android_reverse_analytics/index.html","hash":"d55ab3adfeb0eef88ed72d42fa16c046e42a1627","modified":1645257952419},{"_id":"public/2020/04/24/android_reverse_analytics/compilation_assembly.png","hash":"f8837a880e98315c0fda6d0fbab20601f3bcacac","modified":1645212995751},{"_id":"source/hexo.md","hash":"068db9df4f9d0db42a4f39918cd271a42c159d35","modified":1645209745083},{"_id":"source/_posts/linux_command.md","hash":"67da600ac913247098a9d75b09508e119514c68b","modified":1645212772196},{"_id":"source/_posts/computer_network_basics copy.md","hash":"95479e98424da46cb7cf75e6514ef68a8b149c67","modified":1645212739559},{"_id":"source/_posts/selenium.md","hash":"f31e59ba1dfb2188e0d85699da505dc85e18cb64","modified":1645352100581},{"_id":"public/hexo.html","hash":"cfd2016d9e98a1f316b3f2b8ac8468eb16ff0874","modified":1645209765860},{"_id":"public/2020/04/28/linux_command/index.html","hash":"133db5079f1fc5bd3bcd0b4ce57b1e6bead2a17c","modified":1645257952419},{"_id":"public/2020/04/28/computer_network_basics copy/index.html","hash":"e6dfca731dbdf6033f09d578821e170185c11bff","modified":1645257952419},{"_id":"public/2020/04/24/selenium/index.html","hash":"a7c8a7f018840a7028bdaf4722f22df8aaaea5de","modified":1645369255932},{"_id":"source/_posts/chat_system_web.md","hash":"0887aa680c6aa80c288f3ca5e66cec816a97aa4c","modified":1645212451879},{"_id":"source/_posts/git_command.md","hash":"f1807a37fcb75f007919e8b7c96d802c66ae3245","modified":1645212813789},{"_id":"source/_posts/hexo.md","hash":"c0d5b4148bd6fe25534411550bafc6cede273857","modified":1645351864000},{"_id":"public/2020/04/22/chat_system_web/index.html","hash":"0912a21cac52bcc2fed092197e413d83862f102e","modified":1645257952419},{"_id":"public/2018/11/07/hexo/index.html","hash":"beccf8c9283b8b87a2d45f4fea9875ba0260c6a2","modified":1645369255932},{"_id":"public/2018/11/07/git_command/index.html","hash":"405a0b1dd9c94e3bf725e99feb2a7f1fa784d7a3","modified":1645257952419},{"_id":"public/categories/Application/index.html","hash":"b71baead2dae286a4d612c7a5548d6ae8233bdc5","modified":1645369255932},{"_id":"public/categories/Command/index.html","hash":"220feaf7e76dece5c5533df4e9db23feacbde2c3","modified":1645369255932},{"_id":"public/tags/Web/index.html","hash":"a8e4b0b03358a43ff93c631c21002d36f3cb1e63","modified":1645369255932},{"_id":"public/tags/Git/index.html","hash":"c6280412ce759cf0511b5b0ce401ddb2fbce3732","modified":1645369255932},{"_id":"public/categories/Computer-Network/index.html","hash":"fb06e61e48b5c1aca1a3682675d9409d227e7c48","modified":1645369255932},{"_id":"public/categories/Test/index.html","hash":"ef89211a0793a4c91357ef07abf9ab03115ffd45","modified":1645369255932},{"_id":"public/categories/Other/index.html","hash":"d3e147b890f0e5e3f05b6829a17e897fd11c6a12","modified":1645213299263},{"_id":"public/tags/Automation-Test/index.html","hash":"703980a9c8d3a9ad2cc060b90172a11adf6f0825","modified":1645369255932},{"_id":"source/_posts/favicon.ico.png","hash":"6da8c6d5fb9e91a776a862fbcea17f292ce2ee1f","modified":1645253823272},{"_id":"source/_posts/favicon.ico","hash":"6da8c6d5fb9e91a776a862fbcea17f292ce2ee1f","modified":1645253963727},{"_id":"source/favicon.ico","hash":"6da8c6d5fb9e91a776a862fbcea17f292ce2ee1f","modified":1645253989739},{"_id":"public/favicon.ico","hash":"6da8c6d5fb9e91a776a862fbcea17f292ce2ee1f","modified":1645342999884},{"_id":"source/_posts/about.md","hash":"d12ac3c1bec374b407ad6a2d028da76121bcbe2e","modified":1645254828142},{"_id":"public/2022/02/19/about/index.html","hash":"0516ff2236ac282bd05783371864d127a0c535ca","modified":1645254909309},{"_id":"public/categories/Uncategorized/index.html","hash":"46970eb291969df441907823ebb1f7cf8d05f600","modified":1645369255932},{"_id":"source/_posts/coding_interview/coding_interview_3.md","hash":"23946d90bcac1944979e65bd7c9cffb237b4dfad","modified":1645257882532},{"_id":"source/about.md","hash":"05ce2ada3cd42c540de70de7fcd4874e1bedb544","modified":1645343960590},{"_id":"public/about.html","hash":"8d5da8eed71d428a81bdae20338b32bd6fe5898d","modified":1645369255932},{"_id":"public/categories/Interview-Guide/index.html","hash":"83b1aff2278f0728e3f5ee7b3d079a2fce7c8c30","modified":1645257952419},{"_id":"public/2020/04/24/coding_interview/coding_interview_3/index.html","hash":"ec9ce572e2db93b4d92da9b6613ac1a35b6bfc01","modified":1645257952419},{"_id":"source/_posts/computer-network-basics.md","hash":"e851db3c866e9578a380602ef89ab76b1aeb4e48","modified":1645352081547},{"_id":"source/_posts/android-reverse-analytics.md","hash":"69465a9fb7a05cf2e0e396e1ce26e7f736dcb280","modified":1645351831322},{"_id":"source/_posts/chat-system-web.md","hash":"3e26edeb247551e59e7457cf40cea97fb09ccda1","modified":1645351847429},{"_id":"source/_posts/git-command.md","hash":"b6e82917b092f7371b00dc350441e5efbbe220fe","modified":1645351859207},{"_id":"source/_posts/linux-command.md","hash":"fcaf4db7d0a4707342ef91027e5264b4db1a8e39","modified":1645352094338},{"_id":"source/_posts/coding-interview/coding-interview-3.md","hash":"0358411e0e7f05fee4c5969dcea965a9827859f4","modified":1645351788418},{"_id":"source/_posts/coding-interview/coding-interview-0.md","hash":"1342b5e866ce4d7f94483ca9f408a1ce6c7039f6","modified":1645343960578},{"_id":"source/_posts/android-reverse-analytics/compilation-assembly.png","hash":"f8837a880e98315c0fda6d0fbab20601f3bcacac","modified":1645258929727},{"_id":"public/2022/02/19/coding-interview/coding-interview-0/index.html","hash":"cfeff1517faa8cd290dc286b426c5f14a945771c","modified":1645369255932},{"_id":"public/2020/04/28/computer-network-basics/index.html","hash":"2b1e195e24600704232edc88e10322eec600ca95","modified":1645369255932},{"_id":"public/2020/04/28/linux-command/index.html","hash":"8aae7713d09a7a5e2504f4d51179ec36ece61bbf","modified":1645369255932},{"_id":"public/2020/04/24/android-reverse-analytics/index.html","hash":"e8963019e6c6b8657b563e70d6af4c83578e4f35","modified":1645369255932},{"_id":"public/2018/11/07/git-command/index.html","hash":"79be074c4766545f346a3af0205bde5211f09c70","modified":1645369255932},{"_id":"public/categories/Coding-Interview-Edition-2/index.html","hash":"d313dc724fa0b9e0f95a2c544d3e342a7de8b2bf","modified":1645369255932},{"_id":"public/2022/02/19/coding-interview/coding-interview-3/index.html","hash":"cc5bbd510e85e13cc7490c8d66a30a95f76aaeec","modified":1645369255932},{"_id":"public/2020/04/22/chat-system-web/index.html","hash":"7f4b9c487c3906ab24b7c0c3bf027fcaf8d79694","modified":1645369255932},{"_id":"source/_posts/azure/azure-data-explorer.md","hash":"ebce36585b620a48310ee656f2701945808bcef4","modified":1645352026869},{"_id":"public/2022/02/19/azure/azure-data-explorer/index.html","hash":"bdb0a6d59378f7288c7fa9b799200053b937e55d","modified":1645369255932},{"_id":"public/categories/Azure/index.html","hash":"a8c433e79811cce264dd60132fa3e5fa906da359","modified":1645369255932},{"_id":"source/_posts/coding-interview/coding-interview-4.md","hash":"4103992b4a072ec240d363571a2e1838a1f0ffbf","modified":1645351795883},{"_id":"public/2022/02/20/coding-interview/coding-interview-4/index.html","hash":"2046aa5b6a541a24b3ea8c4d007dcd043b63dc0a","modified":1645369255932},{"_id":"public/archives/page/2/index.html","hash":"8cb31e14081949507a5ee9db7fd5c07f58d63fa8","modified":1645369255932},{"_id":"public/page/2/index.html","hash":"287937e7246ff58d3f1f134c8d0a88873e2bdc57","modified":1645369255932},{"_id":"public/tags/Array/index.html","hash":"d66e4386795667d11a16f5dc9d22404d33b3e90b","modified":1645369255932},{"_id":"source/_posts/coding-interview/coding-interview-5.md","hash":"8d329190f635db832e7f26c2e54ca03063956542","modified":1645363487313},{"_id":"source/_posts/coding-interview/coding-interview-5/replace-space.jpg","hash":"0050880ac9a469041cad3ba56b6ff0f7bf13b118","modified":1645341643533},{"_id":"public/2022/02/20/coding-interview/coding-interview-5/index.html","hash":"0312b2440175ea26c46b115ab9dc46b057067c00","modified":1645369255932},{"_id":"public/2022/02/20/coding-interview/coding-interview-5/replace-space.jpg","hash":"0050880ac9a469041cad3ba56b6ff0f7bf13b118","modified":1645343085523},{"_id":"public/2020/04/24/android-reverse-analytics/compilation-assembly.png","hash":"f8837a880e98315c0fda6d0fbab20601f3bcacac","modified":1645343584283},{"_id":"source/_posts/android-reverse-analytics/compilation_assembly.png","hash":"f8837a880e98315c0fda6d0fbab20601f3bcacac","modified":1645343469726},{"_id":"public/2020/04/24/android-reverse-analytics/compilation_assembly.png","hash":"f8837a880e98315c0fda6d0fbab20601f3bcacac","modified":1645343476628},{"_id":"source/_posts/coding-interview/coding-interview-6.md","hash":"dc0e77ec43958a6f309b3442b9eee76bafcf3d72","modified":1645369226394},{"_id":"public/2022/02/20/coding-interview/coding-interview-6/index.html","hash":"fa5fae12279114e14c1a012b20d54222d87a6f8c","modified":1645369255932}],"Category":[{"name":"Android","_id":"ckzsprryx000yjcuphpkj7ir4"},{"name":"Android/df","_id":"ckzspte1e0010jcupdo6r2217"},{"name":"Application","_id":"ckzsripwi0006u8upe7qlc1uy"},{"name":"Command","_id":"ckzss6n2e000hu8upbwr5bjr7"},{"name":"Computer Network","_id":"ckzst6qjg0000xgup6o5c48yw"},{"name":"Other","_id":"ckzst76990002xgup155z44zv"},{"name":"Test","_id":"ckzst7lfm0005xgup6edudx94"},{"name":"_Other","_id":"ckzst8oqv0009xgup6ks60yio"},{"name":"Uncategorized","_id":"ckztiaa9y0001l4up65cdfv9s"},{"name":"Interview Guide","_id":"ckztk420300024sup6h8317nj"},{"name":"Coding Interview Edition 2","_id":"ckztkpext000hxoup7y9wbkxr"},{"name":"Azure","_id":"ckztmbsre0001mgupcigsb2p0"}],"Data":[],"Page":[{"title":"About Me","date":"2022-02-19T07:13:48.000Z","tags":null,"_content":"","source":"about.md","raw":"---\ntitle: About Me\ndate: 2022-02-19 15:13:48\ntags:\n---\n","updated":"2022-02-20T07:59:20.590Z","path":"about.html","_id":"ckztk41zy00004sup4bxae3w1","comments":1,"layout":"page","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"Selenium自动化测试","date":"2020-04-23T16:00:00.000Z","_content":"\n> _Primarily **Selenium** is for automating web applications for testing purposes, but is certainly not limited to just that. Boring web-based administration tasks can (and should) also be automated as well._\n\n<!--more-->\n\n## 介绍\nSelenium支持多种语言，包括Java、JS和Python等。\n\n## 准备工作\n1. 下载安装Selenium：```$ pip install Selenium```\n2. 下载chromedriver\n\n## 打开测试页面\n```\nfrom selenium import webdriver\n\ndriver = webdriver.Chrome(executable_path='<driver_path>/chromedriver')\ndriver.get(\"<url>\")\n```\n其中```<driver_path>```指的是存放chromedriver的位置，```<url>```是我们要进行测试的页面地址。做完了这一步，运行就可以看到chrome浏览器自动打开到指定的页面了。\n\n## 选择及操作元素\n\n## 其它有用操作\n\n## 可能遇到的问题\niframe\n已打开页面挂载脚本","source":"_posts/selenium.md","raw":"---\ntitle: Selenium自动化测试\ndate: 2020-04-24\ncategories: Test\ntags: Automation Test\n---\n\n> _Primarily **Selenium** is for automating web applications for testing purposes, but is certainly not limited to just that. Boring web-based administration tasks can (and should) also be automated as well._\n\n<!--more-->\n\n## 介绍\nSelenium支持多种语言，包括Java、JS和Python等。\n\n## 准备工作\n1. 下载安装Selenium：```$ pip install Selenium```\n2. 下载chromedriver\n\n## 打开测试页面\n```\nfrom selenium import webdriver\n\ndriver = webdriver.Chrome(executable_path='<driver_path>/chromedriver')\ndriver.get(\"<url>\")\n```\n其中```<driver_path>```指的是存放chromedriver的位置，```<url>```是我们要进行测试的页面地址。做完了这一步，运行就可以看到chrome浏览器自动打开到指定的页面了。\n\n## 选择及操作元素\n\n## 其它有用操作\n\n## 可能遇到的问题\niframe\n已打开页面挂载脚本","slug":"selenium","published":1,"updated":"2022-02-20T10:15:00.581Z","_id":"ckzsrf1410002zcup14cifb25","comments":1,"layout":"post","photos":[],"link":"","content":"<blockquote>\n<p><em>Primarily <strong>Selenium</strong> is for automating web applications for testing purposes, but is certainly not limited to just that. Boring web-based administration tasks can (and should) also be automated as well.</em></p>\n</blockquote>\n<span id=\"more\"></span>\n\n<h2 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h2><p>Selenium支持多种语言，包括Java、JS和Python等。</p>\n<h2 id=\"准备工作\"><a href=\"#准备工作\" class=\"headerlink\" title=\"准备工作\"></a>准备工作</h2><ol>\n<li>下载安装Selenium：<code>$ pip install Selenium</code></li>\n<li>下载chromedriver</li>\n</ol>\n<h2 id=\"打开测试页面\"><a href=\"#打开测试页面\" class=\"headerlink\" title=\"打开测试页面\"></a>打开测试页面</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">from selenium import webdriver</span><br><span class=\"line\"></span><br><span class=\"line\">driver = webdriver.Chrome(executable_path=&#x27;&lt;driver_path&gt;/chromedriver&#x27;)</span><br><span class=\"line\">driver.get(&quot;&lt;url&gt;&quot;)</span><br></pre></td></tr></table></figure>\n<p>其中<code>&lt;driver_path&gt;</code>指的是存放chromedriver的位置，<code>&lt;url&gt;</code>是我们要进行测试的页面地址。做完了这一步，运行就可以看到chrome浏览器自动打开到指定的页面了。</p>\n<h2 id=\"选择及操作元素\"><a href=\"#选择及操作元素\" class=\"headerlink\" title=\"选择及操作元素\"></a>选择及操作元素</h2><h2 id=\"其它有用操作\"><a href=\"#其它有用操作\" class=\"headerlink\" title=\"其它有用操作\"></a>其它有用操作</h2><h2 id=\"可能遇到的问题\"><a href=\"#可能遇到的问题\" class=\"headerlink\" title=\"可能遇到的问题\"></a>可能遇到的问题</h2><p>iframe<br>已打开页面挂载脚本</p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p><em>Primarily <strong>Selenium</strong> is for automating web applications for testing purposes, but is certainly not limited to just that. Boring web-based administration tasks can (and should) also be automated as well.</em></p>\n</blockquote>","more":"<h2 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h2><p>Selenium支持多种语言，包括Java、JS和Python等。</p>\n<h2 id=\"准备工作\"><a href=\"#准备工作\" class=\"headerlink\" title=\"准备工作\"></a>准备工作</h2><ol>\n<li>下载安装Selenium：<code>$ pip install Selenium</code></li>\n<li>下载chromedriver</li>\n</ol>\n<h2 id=\"打开测试页面\"><a href=\"#打开测试页面\" class=\"headerlink\" title=\"打开测试页面\"></a>打开测试页面</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">from selenium import webdriver</span><br><span class=\"line\"></span><br><span class=\"line\">driver = webdriver.Chrome(executable_path=&#x27;&lt;driver_path&gt;/chromedriver&#x27;)</span><br><span class=\"line\">driver.get(&quot;&lt;url&gt;&quot;)</span><br></pre></td></tr></table></figure>\n<p>其中<code>&lt;driver_path&gt;</code>指的是存放chromedriver的位置，<code>&lt;url&gt;</code>是我们要进行测试的页面地址。做完了这一步，运行就可以看到chrome浏览器自动打开到指定的页面了。</p>\n<h2 id=\"选择及操作元素\"><a href=\"#选择及操作元素\" class=\"headerlink\" title=\"选择及操作元素\"></a>选择及操作元素</h2><h2 id=\"其它有用操作\"><a href=\"#其它有用操作\" class=\"headerlink\" title=\"其它有用操作\"></a>其它有用操作</h2><h2 id=\"可能遇到的问题\"><a href=\"#可能遇到的问题\" class=\"headerlink\" title=\"可能遇到的问题\"></a>可能遇到的问题</h2><p>iframe<br>已打开页面挂载脚本</p>"},{"title":"Hexo+GitHub个人博客部署","date":"2018-11-06T16:00:00.000Z","_content":"\n**Hexo**是一个快速、简洁且高效的博客框架，利用了Node.js支持将Markdown文件渲染成网页文件，并一键部署到GitHub上。\n\n<!--more-->\n\n## 前置环境及条件\n- Git\n- GitHub账号\n- Node.js\n\n## GitHub代码库部署\n在GitHub创建新仓库，取名为xxx.github.io，其中xxx是自己决定的名字，之后xxx.github.io将成为访问个人博客的域名。\n\n## Hexo安装和初始化\nHexo是基于markdown的个人博客框架，使用者编写markdown文章，hexo将自动生成html静态网页文件及相关的css和js等文件。\n\n1. 在命令提示符输入```$ npm install hexo-cli -g```并回车（注意：Node.js配置失败将不能使用```$ npm```命令），接着等待hexo下载完成\n2. 进入想要放置博客项目的位置下，输入```$ hexo init xxx```并回车，其中xxx为博客项目名称,也可以创建好项目空文件夹，进入后直接输入```$ hexo init```。\n3. 在博客项目的位置下打开命令提示符，输入```$ hexo server```运行服务器。在浏览器输入默认地址localhost:4000，如果浏览器显示成功则hexo初始化成功。如果显示localhost发送的响应无效，请检查协议是否为https，若是请改为http。\n\n## Hexo创建博客\n如初始化过程中所说创建好博客项目，则会看到自动创建好的目录结构，其中source和themes是使用者最常用的两个文件夹。\n- source: 存放markdown文件形式的文章，以及图片和视频等资源\n- themes: 存放博客主题，默认为landscape\n\n1. 寻找并设置自己喜欢的主题\n\n    1. 寻找主题\n    在[https://hexo.io/themes/index.html](https://hexo.io/themes/index.html)可以查找，但是这些主题貌似都不是官方设计的，相当于主题商城，只不过都是免费的。所以该网页不直接提供下载链接，只提供演示链接；有两种方法找到下载链接，一种在演示博客中找到github项目的链接；另一种直接在github搜索主题名字。\n\n    2. 下载配置主题\n    将GitHub上对应主题项目克隆到本地项目下themes文件夹中，在_config.yml配置文件中修改主题项目的名称，比如这里使用的是[tufu9441/maupassant-hexo](https://github.com/tufu9441/maupassant-hexo)，修改博客项目根目录下_config.yml：\n    ```\n    # Extensions\n    ## Plugins: https://hexo.io/plugins/\n    ## Themes: https://hexo.io/themes/\n    theme: xxx\n    ```\n    接着就可以通过修改主题文件夹下_config.yml文件（注意不是根目录下的那个）进行个性化设置了，具体操作因不同主题而异，设置规范以主题项目说明为准。\n\n2. 修改_config.yml基本配置\n\n    - 网页基本信息\n    ```\n    # Site\n    title: xxx\n    subtitle:\n    description:\n    keywords:\n    author: xxx\n    language: zh-CN\n    timezone: Asia/Shanghai\n    ```\n\n    - 网页地址\n    ```\n    # URL\n    url: http://xxx.github.io\n    root: /\n    permalink: :year/:month/:day/:title/\n    permalink_defaults:\n    ```\n\n    - GitHub连接\n    ```\n    # Deployment\n    ## Docs: https://hexo.io/docs/deployment.html\n    deploy:\n    type: git\n    repo: https://github.com/xxx/xxx.github.io.git\n    branch: master\n    ```\n    其中repo为GitHub博客项目的位置，比如我的项目位置https://github.com/lotuny/lotuny.github.io.git\n\n3. 生成博客并上传到GitHub\n\n    使用Hexo自动生成静态网页，这里提供了常用命令以便快速查阅。详细文档可查询https://hexo.io/docs/\n\n    - ```$ hexo server```或```$ hexo s```在本地运行服务器预览博客效果\n    - ```$ hexo generate```或```$ hexo g```生成静态网页并建好网站项目\n    - ```$ hexo deploy```或```$ hexo d```将博客网站项目推到GitHub\n\n    **Tip(s)**: generate一定要在deploy之前完成！generate出来的网页文件存放在/public文件夹中，然后deploy才能将public下的所有文件push到GitHub。\n    \n## 避坑指南\n本地Hexo博客项目和GitHub博客项目是不一样的，可以理解为本地Hexo项目包含了GitHub博客项目。这就意味着，如果你想多地保存你的Hexo项目及其markdown文件，请务必将其完整地储存在云端，而依赖deploy自动push得到的代码库（xxx.github.io）是不能反向恢复成Hexo项目的。","source":"_posts/hexo.md","raw":"---\ntitle: Hexo+GitHub个人博客部署\ndate: 2018-11-07\ncategories: Uncategorized\ntags: Blog\n---\n\n**Hexo**是一个快速、简洁且高效的博客框架，利用了Node.js支持将Markdown文件渲染成网页文件，并一键部署到GitHub上。\n\n<!--more-->\n\n## 前置环境及条件\n- Git\n- GitHub账号\n- Node.js\n\n## GitHub代码库部署\n在GitHub创建新仓库，取名为xxx.github.io，其中xxx是自己决定的名字，之后xxx.github.io将成为访问个人博客的域名。\n\n## Hexo安装和初始化\nHexo是基于markdown的个人博客框架，使用者编写markdown文章，hexo将自动生成html静态网页文件及相关的css和js等文件。\n\n1. 在命令提示符输入```$ npm install hexo-cli -g```并回车（注意：Node.js配置失败将不能使用```$ npm```命令），接着等待hexo下载完成\n2. 进入想要放置博客项目的位置下，输入```$ hexo init xxx```并回车，其中xxx为博客项目名称,也可以创建好项目空文件夹，进入后直接输入```$ hexo init```。\n3. 在博客项目的位置下打开命令提示符，输入```$ hexo server```运行服务器。在浏览器输入默认地址localhost:4000，如果浏览器显示成功则hexo初始化成功。如果显示localhost发送的响应无效，请检查协议是否为https，若是请改为http。\n\n## Hexo创建博客\n如初始化过程中所说创建好博客项目，则会看到自动创建好的目录结构，其中source和themes是使用者最常用的两个文件夹。\n- source: 存放markdown文件形式的文章，以及图片和视频等资源\n- themes: 存放博客主题，默认为landscape\n\n1. 寻找并设置自己喜欢的主题\n\n    1. 寻找主题\n    在[https://hexo.io/themes/index.html](https://hexo.io/themes/index.html)可以查找，但是这些主题貌似都不是官方设计的，相当于主题商城，只不过都是免费的。所以该网页不直接提供下载链接，只提供演示链接；有两种方法找到下载链接，一种在演示博客中找到github项目的链接；另一种直接在github搜索主题名字。\n\n    2. 下载配置主题\n    将GitHub上对应主题项目克隆到本地项目下themes文件夹中，在_config.yml配置文件中修改主题项目的名称，比如这里使用的是[tufu9441/maupassant-hexo](https://github.com/tufu9441/maupassant-hexo)，修改博客项目根目录下_config.yml：\n    ```\n    # Extensions\n    ## Plugins: https://hexo.io/plugins/\n    ## Themes: https://hexo.io/themes/\n    theme: xxx\n    ```\n    接着就可以通过修改主题文件夹下_config.yml文件（注意不是根目录下的那个）进行个性化设置了，具体操作因不同主题而异，设置规范以主题项目说明为准。\n\n2. 修改_config.yml基本配置\n\n    - 网页基本信息\n    ```\n    # Site\n    title: xxx\n    subtitle:\n    description:\n    keywords:\n    author: xxx\n    language: zh-CN\n    timezone: Asia/Shanghai\n    ```\n\n    - 网页地址\n    ```\n    # URL\n    url: http://xxx.github.io\n    root: /\n    permalink: :year/:month/:day/:title/\n    permalink_defaults:\n    ```\n\n    - GitHub连接\n    ```\n    # Deployment\n    ## Docs: https://hexo.io/docs/deployment.html\n    deploy:\n    type: git\n    repo: https://github.com/xxx/xxx.github.io.git\n    branch: master\n    ```\n    其中repo为GitHub博客项目的位置，比如我的项目位置https://github.com/lotuny/lotuny.github.io.git\n\n3. 生成博客并上传到GitHub\n\n    使用Hexo自动生成静态网页，这里提供了常用命令以便快速查阅。详细文档可查询https://hexo.io/docs/\n\n    - ```$ hexo server```或```$ hexo s```在本地运行服务器预览博客效果\n    - ```$ hexo generate```或```$ hexo g```生成静态网页并建好网站项目\n    - ```$ hexo deploy```或```$ hexo d```将博客网站项目推到GitHub\n\n    **Tip(s)**: generate一定要在deploy之前完成！generate出来的网页文件存放在/public文件夹中，然后deploy才能将public下的所有文件push到GitHub。\n    \n## 避坑指南\n本地Hexo博客项目和GitHub博客项目是不一样的，可以理解为本地Hexo项目包含了GitHub博客项目。这就意味着，如果你想多地保存你的Hexo项目及其markdown文件，请务必将其完整地储存在云端，而依赖deploy自动push得到的代码库（xxx.github.io）是不能反向恢复成Hexo项目的。","slug":"hexo","published":1,"updated":"2022-02-20T10:11:04.000Z","_id":"ckzsrfl500000u8up3x3bg07e","comments":1,"layout":"post","photos":[],"link":"","content":"<p><strong>Hexo</strong>是一个快速、简洁且高效的博客框架，利用了Node.js支持将Markdown文件渲染成网页文件，并一键部署到GitHub上。</p>\n<span id=\"more\"></span>\n\n<h2 id=\"前置环境及条件\"><a href=\"#前置环境及条件\" class=\"headerlink\" title=\"前置环境及条件\"></a>前置环境及条件</h2><ul>\n<li>Git</li>\n<li>GitHub账号</li>\n<li>Node.js</li>\n</ul>\n<h2 id=\"GitHub代码库部署\"><a href=\"#GitHub代码库部署\" class=\"headerlink\" title=\"GitHub代码库部署\"></a>GitHub代码库部署</h2><p>在GitHub创建新仓库，取名为xxx.github.io，其中xxx是自己决定的名字，之后xxx.github.io将成为访问个人博客的域名。</p>\n<h2 id=\"Hexo安装和初始化\"><a href=\"#Hexo安装和初始化\" class=\"headerlink\" title=\"Hexo安装和初始化\"></a>Hexo安装和初始化</h2><p>Hexo是基于markdown的个人博客框架，使用者编写markdown文章，hexo将自动生成html静态网页文件及相关的css和js等文件。</p>\n<ol>\n<li>在命令提示符输入<code>$ npm install hexo-cli -g</code>并回车（注意：Node.js配置失败将不能使用<code>$ npm</code>命令），接着等待hexo下载完成</li>\n<li>进入想要放置博客项目的位置下，输入<code>$ hexo init xxx</code>并回车，其中xxx为博客项目名称,也可以创建好项目空文件夹，进入后直接输入<code>$ hexo init</code>。</li>\n<li>在博客项目的位置下打开命令提示符，输入<code>$ hexo server</code>运行服务器。在浏览器输入默认地址localhost:4000，如果浏览器显示成功则hexo初始化成功。如果显示localhost发送的响应无效，请检查协议是否为https，若是请改为http。</li>\n</ol>\n<h2 id=\"Hexo创建博客\"><a href=\"#Hexo创建博客\" class=\"headerlink\" title=\"Hexo创建博客\"></a>Hexo创建博客</h2><p>如初始化过程中所说创建好博客项目，则会看到自动创建好的目录结构，其中source和themes是使用者最常用的两个文件夹。</p>\n<ul>\n<li>source: 存放markdown文件形式的文章，以及图片和视频等资源</li>\n<li>themes: 存放博客主题，默认为landscape</li>\n</ul>\n<ol>\n<li><p>寻找并设置自己喜欢的主题</p>\n<ol>\n<li><p>寻找主题<br>在<a href=\"https://hexo.io/themes/index.html\">https://hexo.io/themes/index.html</a>可以查找，但是这些主题貌似都不是官方设计的，相当于主题商城，只不过都是免费的。所以该网页不直接提供下载链接，只提供演示链接；有两种方法找到下载链接，一种在演示博客中找到github项目的链接；另一种直接在github搜索主题名字。</p>\n</li>\n<li><p>下载配置主题<br>将GitHub上对应主题项目克隆到本地项目下themes文件夹中，在_config.yml配置文件中修改主题项目的名称，比如这里使用的是<a href=\"https://github.com/tufu9441/maupassant-hexo\">tufu9441/maupassant-hexo</a>，修改博客项目根目录下_config.yml：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># Extensions</span><br><span class=\"line\">## Plugins: https://hexo.io/plugins/</span><br><span class=\"line\">## Themes: https://hexo.io/themes/</span><br><span class=\"line\">theme: xxx</span><br></pre></td></tr></table></figure>\n<p>接着就可以通过修改主题文件夹下_config.yml文件（注意不是根目录下的那个）进行个性化设置了，具体操作因不同主题而异，设置规范以主题项目说明为准。</p>\n</li>\n</ol>\n</li>\n<li><p>修改_config.yml基本配置</p>\n<ul>\n<li><p>网页基本信息</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># Site</span><br><span class=\"line\">title: xxx</span><br><span class=\"line\">subtitle:</span><br><span class=\"line\">description:</span><br><span class=\"line\">keywords:</span><br><span class=\"line\">author: xxx</span><br><span class=\"line\">language: zh-CN</span><br><span class=\"line\">timezone: Asia/Shanghai</span><br></pre></td></tr></table></figure></li>\n<li><p>网页地址</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># URL</span><br><span class=\"line\">url: http://xxx.github.io</span><br><span class=\"line\">root: /</span><br><span class=\"line\">permalink: :year/:month/:day/:title/</span><br><span class=\"line\">permalink_defaults:</span><br></pre></td></tr></table></figure></li>\n<li><p>GitHub连接</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># Deployment</span><br><span class=\"line\">## Docs: https://hexo.io/docs/deployment.html</span><br><span class=\"line\">deploy:</span><br><span class=\"line\">type: git</span><br><span class=\"line\">repo: https://github.com/xxx/xxx.github.io.git</span><br><span class=\"line\">branch: master</span><br></pre></td></tr></table></figure>\n<p>其中repo为GitHub博客项目的位置，比如我的项目位置<a href=\"https://github.com/lotuny/lotuny.github.io.git\">https://github.com/lotuny/lotuny.github.io.git</a></p>\n</li>\n</ul>\n</li>\n<li><p>生成博客并上传到GitHub</p>\n<p> 使用Hexo自动生成静态网页，这里提供了常用命令以便快速查阅。详细文档可查询<a href=\"https://hexo.io/docs/\">https://hexo.io/docs/</a></p>\n<ul>\n<li><code>$ hexo server</code>或<code>$ hexo s</code>在本地运行服务器预览博客效果</li>\n<li><code>$ hexo generate</code>或<code>$ hexo g</code>生成静态网页并建好网站项目</li>\n<li><code>$ hexo deploy</code>或<code>$ hexo d</code>将博客网站项目推到GitHub</li>\n</ul>\n<p> <strong>Tip(s)</strong>: generate一定要在deploy之前完成！generate出来的网页文件存放在/public文件夹中，然后deploy才能将public下的所有文件push到GitHub。</p>\n</li>\n</ol>\n<h2 id=\"避坑指南\"><a href=\"#避坑指南\" class=\"headerlink\" title=\"避坑指南\"></a>避坑指南</h2><p>本地Hexo博客项目和GitHub博客项目是不一样的，可以理解为本地Hexo项目包含了GitHub博客项目。这就意味着，如果你想多地保存你的Hexo项目及其markdown文件，请务必将其完整地储存在云端，而依赖deploy自动push得到的代码库（xxx.github.io）是不能反向恢复成Hexo项目的。</p>\n","site":{"data":{}},"excerpt":"<p><strong>Hexo</strong>是一个快速、简洁且高效的博客框架，利用了Node.js支持将Markdown文件渲染成网页文件，并一键部署到GitHub上。</p>","more":"<h2 id=\"前置环境及条件\"><a href=\"#前置环境及条件\" class=\"headerlink\" title=\"前置环境及条件\"></a>前置环境及条件</h2><ul>\n<li>Git</li>\n<li>GitHub账号</li>\n<li>Node.js</li>\n</ul>\n<h2 id=\"GitHub代码库部署\"><a href=\"#GitHub代码库部署\" class=\"headerlink\" title=\"GitHub代码库部署\"></a>GitHub代码库部署</h2><p>在GitHub创建新仓库，取名为xxx.github.io，其中xxx是自己决定的名字，之后xxx.github.io将成为访问个人博客的域名。</p>\n<h2 id=\"Hexo安装和初始化\"><a href=\"#Hexo安装和初始化\" class=\"headerlink\" title=\"Hexo安装和初始化\"></a>Hexo安装和初始化</h2><p>Hexo是基于markdown的个人博客框架，使用者编写markdown文章，hexo将自动生成html静态网页文件及相关的css和js等文件。</p>\n<ol>\n<li>在命令提示符输入<code>$ npm install hexo-cli -g</code>并回车（注意：Node.js配置失败将不能使用<code>$ npm</code>命令），接着等待hexo下载完成</li>\n<li>进入想要放置博客项目的位置下，输入<code>$ hexo init xxx</code>并回车，其中xxx为博客项目名称,也可以创建好项目空文件夹，进入后直接输入<code>$ hexo init</code>。</li>\n<li>在博客项目的位置下打开命令提示符，输入<code>$ hexo server</code>运行服务器。在浏览器输入默认地址localhost:4000，如果浏览器显示成功则hexo初始化成功。如果显示localhost发送的响应无效，请检查协议是否为https，若是请改为http。</li>\n</ol>\n<h2 id=\"Hexo创建博客\"><a href=\"#Hexo创建博客\" class=\"headerlink\" title=\"Hexo创建博客\"></a>Hexo创建博客</h2><p>如初始化过程中所说创建好博客项目，则会看到自动创建好的目录结构，其中source和themes是使用者最常用的两个文件夹。</p>\n<ul>\n<li>source: 存放markdown文件形式的文章，以及图片和视频等资源</li>\n<li>themes: 存放博客主题，默认为landscape</li>\n</ul>\n<ol>\n<li><p>寻找并设置自己喜欢的主题</p>\n<ol>\n<li><p>寻找主题<br>在<a href=\"https://hexo.io/themes/index.html\">https://hexo.io/themes/index.html</a>可以查找，但是这些主题貌似都不是官方设计的，相当于主题商城，只不过都是免费的。所以该网页不直接提供下载链接，只提供演示链接；有两种方法找到下载链接，一种在演示博客中找到github项目的链接；另一种直接在github搜索主题名字。</p>\n</li>\n<li><p>下载配置主题<br>将GitHub上对应主题项目克隆到本地项目下themes文件夹中，在_config.yml配置文件中修改主题项目的名称，比如这里使用的是<a href=\"https://github.com/tufu9441/maupassant-hexo\">tufu9441/maupassant-hexo</a>，修改博客项目根目录下_config.yml：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># Extensions</span><br><span class=\"line\">## Plugins: https://hexo.io/plugins/</span><br><span class=\"line\">## Themes: https://hexo.io/themes/</span><br><span class=\"line\">theme: xxx</span><br></pre></td></tr></table></figure>\n<p>接着就可以通过修改主题文件夹下_config.yml文件（注意不是根目录下的那个）进行个性化设置了，具体操作因不同主题而异，设置规范以主题项目说明为准。</p>\n</li>\n</ol>\n</li>\n<li><p>修改_config.yml基本配置</p>\n<ul>\n<li><p>网页基本信息</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># Site</span><br><span class=\"line\">title: xxx</span><br><span class=\"line\">subtitle:</span><br><span class=\"line\">description:</span><br><span class=\"line\">keywords:</span><br><span class=\"line\">author: xxx</span><br><span class=\"line\">language: zh-CN</span><br><span class=\"line\">timezone: Asia/Shanghai</span><br></pre></td></tr></table></figure></li>\n<li><p>网页地址</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># URL</span><br><span class=\"line\">url: http://xxx.github.io</span><br><span class=\"line\">root: /</span><br><span class=\"line\">permalink: :year/:month/:day/:title/</span><br><span class=\"line\">permalink_defaults:</span><br></pre></td></tr></table></figure></li>\n<li><p>GitHub连接</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># Deployment</span><br><span class=\"line\">## Docs: https://hexo.io/docs/deployment.html</span><br><span class=\"line\">deploy:</span><br><span class=\"line\">type: git</span><br><span class=\"line\">repo: https://github.com/xxx/xxx.github.io.git</span><br><span class=\"line\">branch: master</span><br></pre></td></tr></table></figure>\n<p>其中repo为GitHub博客项目的位置，比如我的项目位置<a href=\"https://github.com/lotuny/lotuny.github.io.git\">https://github.com/lotuny/lotuny.github.io.git</a></p>\n</li>\n</ul>\n</li>\n<li><p>生成博客并上传到GitHub</p>\n<p> 使用Hexo自动生成静态网页，这里提供了常用命令以便快速查阅。详细文档可查询<a href=\"https://hexo.io/docs/\">https://hexo.io/docs/</a></p>\n<ul>\n<li><code>$ hexo server</code>或<code>$ hexo s</code>在本地运行服务器预览博客效果</li>\n<li><code>$ hexo generate</code>或<code>$ hexo g</code>生成静态网页并建好网站项目</li>\n<li><code>$ hexo deploy</code>或<code>$ hexo d</code>将博客网站项目推到GitHub</li>\n</ul>\n<p> <strong>Tip(s)</strong>: generate一定要在deploy之前完成！generate出来的网页文件存放在/public文件夹中，然后deploy才能将public下的所有文件push到GitHub。</p>\n</li>\n</ol>\n<h2 id=\"避坑指南\"><a href=\"#避坑指南\" class=\"headerlink\" title=\"避坑指南\"></a>避坑指南</h2><p>本地Hexo博客项目和GitHub博客项目是不一样的，可以理解为本地Hexo项目包含了GitHub博客项目。这就意味着，如果你想多地保存你的Hexo项目及其markdown文件，请务必将其完整地储存在云端，而依赖deploy自动push得到的代码库（xxx.github.io）是不能反向恢复成Hexo项目的。</p>"},{"title":"安卓逆向分析学习","date":"2020-04-23T16:00:00.000Z","toc":true,"_content":"\n对于**安卓逆向分析**我其实只是刚刚入门，或者说入门都不算，所以写这篇文章的目的并不是要教什么干货，而是一方面作为自己的学习笔记方便学而时习之，另一方面希望能给想入门的纯小白一点借鉴作用（在安装工具方面什么的），毕竟我也是小白，看问题的角度应该比较相似叭。\n\n<!--more-->\n\n## 相关概念\n\n我要说的是那些在搞安卓逆向分析之前都不太有机会去深入理解的概念，以及在这个学习课题中比较重要的概念。不全，但至少是我跟着Writeup做了两道14年阿里移动安全挑战赛的题之后认为需要的基本知识储备。\n\n- 编译(Compile)和汇编(Assemble)\n\n    编译指的是将高级语言程序转化成汇编语言程序，汇编则是将汇编语言程序转化成可运行的二进制文件。搞开发的小伙伴应该很熟悉自己使用的高级语言如C、Java、Python，不过运行在虚拟机上的语言并不遵循前面说的“高级语言->汇编语言->二进制文件”。\n\n    高级语言大家都比较熟悉，那什么是汇编语言呢（这句话怎么有股老营销号的感觉）？其实汇编语言就是使用助记符（Mnemonics）来代替和表示特定指令的语言，一个助记符就对应着指令集中的一条命令，一种汇编语言就对应一套指令集，指令集和CPU架构也是一一对应的。\n\n- 指令集\n\n    指令集顾名思义就是指令的集合，指令就是控制CPU的单元操作，不可再分。现存指令集都分为两种：RISC (Reduced Instruction Set Computing)和CISC (Complex Instruction Set Computing)，前者是精简指令集，后者是复杂指令集，区别就是单条指令能做多少事。\n\n    主流指令集就是：Intel x86指令集（复杂）、ARM指令集（精简）和MIPS指令集（精简）。后面提到的IDA Pro这个反编译工具则使用的是ARM指令集的汇编助记符。\n\n- Dalvik & Dex字节码\n\n    虽然安卓应用使用Java语言来开发，但是安卓有自己的虚拟机，还有自己的Android SDK (Software Development Kit)。Dalvik就是安卓虚拟机，在Android 5.0之后被ART (Android Runtime)取代。Dex字节码相当于Java程序的.class文件，是可以直接在安卓虚拟机上运行的文件，文件后缀为dex。\n\n- Smali & Baksmali\n\n    这两个分为是Dalvik的汇编器和反汇编器，三个词都是冰岛语。这里汇编的输入是.smali文件，输出是.dex文件。Android项目在生成apk安装包的过程其实并不产生smali文件。由于已经生成的.dex文件是没办法反编译回java文件的，而.dex文件又是人类不可读的，所以便产生了这么一个中间物，方便程序员调试自己的项目，当然，也方便了攻击者篡改代码。既然是人类可读的，那就有一定的语法，所以smali也算是一种语言。\n\n    ![](/2020/04/24/android-reverse-analytics/compilation-assembly.png)\n\n    编译汇编理解图图片是根据我自己的理解画的，虚线部分不是特别确定。其中左边是一般高级语言程序到可执行文件的编译汇编流程（参考C语言），右边分别是Java和Android的对比图，灰色表示过程，橙色表示虚拟机，方框表示可运行在对应虚拟机上的文件，蓝色表示工具。\n\n- Apk安装包\n\n    [Apk (Android application package)](https://en.wikipedia.org/wiki/Apk_(file_format))就是安卓的应用安装包，本质就是个压缩包，除了包含程序的所有运行文件以外，还有一些格式文件、签名信息等。\n\n- so文件\n\n- native方法\n\n## 工具\n\n- Android Studio/安卓模拟器\n- UI Automator Viewer\n- Jadx\n- Android Killer\n- IDA Pro + Keypatch\n\n## 步骤\n\n1. 打开安卓模拟器安装apk；\n2. 打开UI Automator Viewer查看关键组件的名称；\n3. 打开Jadx反编译apk找到组件创建位置并分析上下文：\n    1. 如果可以通过修改语句实现目的，则打开Android Killer修改smali文件；\n    2. 否则如果用了关键方法为native方法，就找到对应so文件并将其导入IDA Pro进行分析，按F5可查看伪代码，找到关键处可用插件Keypatch修改指令字节；\n4. 用Android Killer重新编译项目打包成apk，并安装到模拟器上查看效果。","source":"_posts/android-reverse-analytics.md","raw":"---\ntitle: 安卓逆向分析学习\ndate: 2020-04-24\ncategories: Android\ntags: Security\ntoc: true\n---\n\n对于**安卓逆向分析**我其实只是刚刚入门，或者说入门都不算，所以写这篇文章的目的并不是要教什么干货，而是一方面作为自己的学习笔记方便学而时习之，另一方面希望能给想入门的纯小白一点借鉴作用（在安装工具方面什么的），毕竟我也是小白，看问题的角度应该比较相似叭。\n\n<!--more-->\n\n## 相关概念\n\n我要说的是那些在搞安卓逆向分析之前都不太有机会去深入理解的概念，以及在这个学习课题中比较重要的概念。不全，但至少是我跟着Writeup做了两道14年阿里移动安全挑战赛的题之后认为需要的基本知识储备。\n\n- 编译(Compile)和汇编(Assemble)\n\n    编译指的是将高级语言程序转化成汇编语言程序，汇编则是将汇编语言程序转化成可运行的二进制文件。搞开发的小伙伴应该很熟悉自己使用的高级语言如C、Java、Python，不过运行在虚拟机上的语言并不遵循前面说的“高级语言->汇编语言->二进制文件”。\n\n    高级语言大家都比较熟悉，那什么是汇编语言呢（这句话怎么有股老营销号的感觉）？其实汇编语言就是使用助记符（Mnemonics）来代替和表示特定指令的语言，一个助记符就对应着指令集中的一条命令，一种汇编语言就对应一套指令集，指令集和CPU架构也是一一对应的。\n\n- 指令集\n\n    指令集顾名思义就是指令的集合，指令就是控制CPU的单元操作，不可再分。现存指令集都分为两种：RISC (Reduced Instruction Set Computing)和CISC (Complex Instruction Set Computing)，前者是精简指令集，后者是复杂指令集，区别就是单条指令能做多少事。\n\n    主流指令集就是：Intel x86指令集（复杂）、ARM指令集（精简）和MIPS指令集（精简）。后面提到的IDA Pro这个反编译工具则使用的是ARM指令集的汇编助记符。\n\n- Dalvik & Dex字节码\n\n    虽然安卓应用使用Java语言来开发，但是安卓有自己的虚拟机，还有自己的Android SDK (Software Development Kit)。Dalvik就是安卓虚拟机，在Android 5.0之后被ART (Android Runtime)取代。Dex字节码相当于Java程序的.class文件，是可以直接在安卓虚拟机上运行的文件，文件后缀为dex。\n\n- Smali & Baksmali\n\n    这两个分为是Dalvik的汇编器和反汇编器，三个词都是冰岛语。这里汇编的输入是.smali文件，输出是.dex文件。Android项目在生成apk安装包的过程其实并不产生smali文件。由于已经生成的.dex文件是没办法反编译回java文件的，而.dex文件又是人类不可读的，所以便产生了这么一个中间物，方便程序员调试自己的项目，当然，也方便了攻击者篡改代码。既然是人类可读的，那就有一定的语法，所以smali也算是一种语言。\n\n    ![](/2020/04/24/android-reverse-analytics/compilation-assembly.png)\n\n    编译汇编理解图图片是根据我自己的理解画的，虚线部分不是特别确定。其中左边是一般高级语言程序到可执行文件的编译汇编流程（参考C语言），右边分别是Java和Android的对比图，灰色表示过程，橙色表示虚拟机，方框表示可运行在对应虚拟机上的文件，蓝色表示工具。\n\n- Apk安装包\n\n    [Apk (Android application package)](https://en.wikipedia.org/wiki/Apk_(file_format))就是安卓的应用安装包，本质就是个压缩包，除了包含程序的所有运行文件以外，还有一些格式文件、签名信息等。\n\n- so文件\n\n- native方法\n\n## 工具\n\n- Android Studio/安卓模拟器\n- UI Automator Viewer\n- Jadx\n- Android Killer\n- IDA Pro + Keypatch\n\n## 步骤\n\n1. 打开安卓模拟器安装apk；\n2. 打开UI Automator Viewer查看关键组件的名称；\n3. 打开Jadx反编译apk找到组件创建位置并分析上下文：\n    1. 如果可以通过修改语句实现目的，则打开Android Killer修改smali文件；\n    2. 否则如果用了关键方法为native方法，就找到对应so文件并将其导入IDA Pro进行分析，按F5可查看伪代码，找到关键处可用插件Keypatch修改指令字节；\n4. 用Android Killer重新编译项目打包成apk，并安装到模拟器上查看效果。","slug":"android-reverse-analytics","published":1,"updated":"2022-02-20T10:10:31.322Z","_id":"ckztkpexg0000xoupcgvj81wr","comments":1,"layout":"post","photos":[],"link":"","content":"<p>对于<strong>安卓逆向分析</strong>我其实只是刚刚入门，或者说入门都不算，所以写这篇文章的目的并不是要教什么干货，而是一方面作为自己的学习笔记方便学而时习之，另一方面希望能给想入门的纯小白一点借鉴作用（在安装工具方面什么的），毕竟我也是小白，看问题的角度应该比较相似叭。</p>\n<span id=\"more\"></span>\n\n<h2 id=\"相关概念\"><a href=\"#相关概念\" class=\"headerlink\" title=\"相关概念\"></a>相关概念</h2><p>我要说的是那些在搞安卓逆向分析之前都不太有机会去深入理解的概念，以及在这个学习课题中比较重要的概念。不全，但至少是我跟着Writeup做了两道14年阿里移动安全挑战赛的题之后认为需要的基本知识储备。</p>\n<ul>\n<li><p>编译(Compile)和汇编(Assemble)</p>\n<p>  编译指的是将高级语言程序转化成汇编语言程序，汇编则是将汇编语言程序转化成可运行的二进制文件。搞开发的小伙伴应该很熟悉自己使用的高级语言如C、Java、Python，不过运行在虚拟机上的语言并不遵循前面说的“高级语言-&gt;汇编语言-&gt;二进制文件”。</p>\n<p>  高级语言大家都比较熟悉，那什么是汇编语言呢（这句话怎么有股老营销号的感觉）？其实汇编语言就是使用助记符（Mnemonics）来代替和表示特定指令的语言，一个助记符就对应着指令集中的一条命令，一种汇编语言就对应一套指令集，指令集和CPU架构也是一一对应的。</p>\n</li>\n<li><p>指令集</p>\n<p>  指令集顾名思义就是指令的集合，指令就是控制CPU的单元操作，不可再分。现存指令集都分为两种：RISC (Reduced Instruction Set Computing)和CISC (Complex Instruction Set Computing)，前者是精简指令集，后者是复杂指令集，区别就是单条指令能做多少事。</p>\n<p>  主流指令集就是：Intel x86指令集（复杂）、ARM指令集（精简）和MIPS指令集（精简）。后面提到的IDA Pro这个反编译工具则使用的是ARM指令集的汇编助记符。</p>\n</li>\n<li><p>Dalvik &amp; Dex字节码</p>\n<p>  虽然安卓应用使用Java语言来开发，但是安卓有自己的虚拟机，还有自己的Android SDK (Software Development Kit)。Dalvik就是安卓虚拟机，在Android 5.0之后被ART (Android Runtime)取代。Dex字节码相当于Java程序的.class文件，是可以直接在安卓虚拟机上运行的文件，文件后缀为dex。</p>\n</li>\n<li><p>Smali &amp; Baksmali</p>\n<p>  这两个分为是Dalvik的汇编器和反汇编器，三个词都是冰岛语。这里汇编的输入是.smali文件，输出是.dex文件。Android项目在生成apk安装包的过程其实并不产生smali文件。由于已经生成的.dex文件是没办法反编译回java文件的，而.dex文件又是人类不可读的，所以便产生了这么一个中间物，方便程序员调试自己的项目，当然，也方便了攻击者篡改代码。既然是人类可读的，那就有一定的语法，所以smali也算是一种语言。</p>\n<p>  <img src=\"/2020/04/24/android-reverse-analytics/compilation-assembly.png\"></p>\n<p>  编译汇编理解图图片是根据我自己的理解画的，虚线部分不是特别确定。其中左边是一般高级语言程序到可执行文件的编译汇编流程（参考C语言），右边分别是Java和Android的对比图，灰色表示过程，橙色表示虚拟机，方框表示可运行在对应虚拟机上的文件，蓝色表示工具。</p>\n</li>\n<li><p>Apk安装包</p>\n<p>  <a href=\"https://en.wikipedia.org/wiki/Apk_(file_format)\">Apk (Android application package)</a>就是安卓的应用安装包，本质就是个压缩包，除了包含程序的所有运行文件以外，还有一些格式文件、签名信息等。</p>\n</li>\n<li><p>so文件</p>\n</li>\n<li><p>native方法</p>\n</li>\n</ul>\n<h2 id=\"工具\"><a href=\"#工具\" class=\"headerlink\" title=\"工具\"></a>工具</h2><ul>\n<li>Android Studio/安卓模拟器</li>\n<li>UI Automator Viewer</li>\n<li>Jadx</li>\n<li>Android Killer</li>\n<li>IDA Pro + Keypatch</li>\n</ul>\n<h2 id=\"步骤\"><a href=\"#步骤\" class=\"headerlink\" title=\"步骤\"></a>步骤</h2><ol>\n<li>打开安卓模拟器安装apk；</li>\n<li>打开UI Automator Viewer查看关键组件的名称；</li>\n<li>打开Jadx反编译apk找到组件创建位置并分析上下文：<ol>\n<li>如果可以通过修改语句实现目的，则打开Android Killer修改smali文件；</li>\n<li>否则如果用了关键方法为native方法，就找到对应so文件并将其导入IDA Pro进行分析，按F5可查看伪代码，找到关键处可用插件Keypatch修改指令字节；</li>\n</ol>\n</li>\n<li>用Android Killer重新编译项目打包成apk，并安装到模拟器上查看效果。</li>\n</ol>\n","site":{"data":{}},"excerpt":"<p>对于<strong>安卓逆向分析</strong>我其实只是刚刚入门，或者说入门都不算，所以写这篇文章的目的并不是要教什么干货，而是一方面作为自己的学习笔记方便学而时习之，另一方面希望能给想入门的纯小白一点借鉴作用（在安装工具方面什么的），毕竟我也是小白，看问题的角度应该比较相似叭。</p>","more":"<h2 id=\"相关概念\"><a href=\"#相关概念\" class=\"headerlink\" title=\"相关概念\"></a>相关概念</h2><p>我要说的是那些在搞安卓逆向分析之前都不太有机会去深入理解的概念，以及在这个学习课题中比较重要的概念。不全，但至少是我跟着Writeup做了两道14年阿里移动安全挑战赛的题之后认为需要的基本知识储备。</p>\n<ul>\n<li><p>编译(Compile)和汇编(Assemble)</p>\n<p>  编译指的是将高级语言程序转化成汇编语言程序，汇编则是将汇编语言程序转化成可运行的二进制文件。搞开发的小伙伴应该很熟悉自己使用的高级语言如C、Java、Python，不过运行在虚拟机上的语言并不遵循前面说的“高级语言-&gt;汇编语言-&gt;二进制文件”。</p>\n<p>  高级语言大家都比较熟悉，那什么是汇编语言呢（这句话怎么有股老营销号的感觉）？其实汇编语言就是使用助记符（Mnemonics）来代替和表示特定指令的语言，一个助记符就对应着指令集中的一条命令，一种汇编语言就对应一套指令集，指令集和CPU架构也是一一对应的。</p>\n</li>\n<li><p>指令集</p>\n<p>  指令集顾名思义就是指令的集合，指令就是控制CPU的单元操作，不可再分。现存指令集都分为两种：RISC (Reduced Instruction Set Computing)和CISC (Complex Instruction Set Computing)，前者是精简指令集，后者是复杂指令集，区别就是单条指令能做多少事。</p>\n<p>  主流指令集就是：Intel x86指令集（复杂）、ARM指令集（精简）和MIPS指令集（精简）。后面提到的IDA Pro这个反编译工具则使用的是ARM指令集的汇编助记符。</p>\n</li>\n<li><p>Dalvik &amp; Dex字节码</p>\n<p>  虽然安卓应用使用Java语言来开发，但是安卓有自己的虚拟机，还有自己的Android SDK (Software Development Kit)。Dalvik就是安卓虚拟机，在Android 5.0之后被ART (Android Runtime)取代。Dex字节码相当于Java程序的.class文件，是可以直接在安卓虚拟机上运行的文件，文件后缀为dex。</p>\n</li>\n<li><p>Smali &amp; Baksmali</p>\n<p>  这两个分为是Dalvik的汇编器和反汇编器，三个词都是冰岛语。这里汇编的输入是.smali文件，输出是.dex文件。Android项目在生成apk安装包的过程其实并不产生smali文件。由于已经生成的.dex文件是没办法反编译回java文件的，而.dex文件又是人类不可读的，所以便产生了这么一个中间物，方便程序员调试自己的项目，当然，也方便了攻击者篡改代码。既然是人类可读的，那就有一定的语法，所以smali也算是一种语言。</p>\n<p>  <img src=\"/2020/04/24/android-reverse-analytics/compilation-assembly.png\"></p>\n<p>  编译汇编理解图图片是根据我自己的理解画的，虚线部分不是特别确定。其中左边是一般高级语言程序到可执行文件的编译汇编流程（参考C语言），右边分别是Java和Android的对比图，灰色表示过程，橙色表示虚拟机，方框表示可运行在对应虚拟机上的文件，蓝色表示工具。</p>\n</li>\n<li><p>Apk安装包</p>\n<p>  <a href=\"https://en.wikipedia.org/wiki/Apk_(file_format)\">Apk (Android application package)</a>就是安卓的应用安装包，本质就是个压缩包，除了包含程序的所有运行文件以外，还有一些格式文件、签名信息等。</p>\n</li>\n<li><p>so文件</p>\n</li>\n<li><p>native方法</p>\n</li>\n</ul>\n<h2 id=\"工具\"><a href=\"#工具\" class=\"headerlink\" title=\"工具\"></a>工具</h2><ul>\n<li>Android Studio/安卓模拟器</li>\n<li>UI Automator Viewer</li>\n<li>Jadx</li>\n<li>Android Killer</li>\n<li>IDA Pro + Keypatch</li>\n</ul>\n<h2 id=\"步骤\"><a href=\"#步骤\" class=\"headerlink\" title=\"步骤\"></a>步骤</h2><ol>\n<li>打开安卓模拟器安装apk；</li>\n<li>打开UI Automator Viewer查看关键组件的名称；</li>\n<li>打开Jadx反编译apk找到组件创建位置并分析上下文：<ol>\n<li>如果可以通过修改语句实现目的，则打开Android Killer修改smali文件；</li>\n<li>否则如果用了关键方法为native方法，就找到对应so文件并将其导入IDA Pro进行分析，按F5可查看伪代码，找到关键处可用插件Keypatch修改指令字节；</li>\n</ol>\n</li>\n<li>用Android Killer重新编译项目打包成apk，并安装到模拟器上查看效果。</li>\n</ol>"},{"title":"分布式聊天系统(Web部分)","date":"2020-04-21T16:00:00.000Z","_content":"\n最近和几个同学刚做完一个为期大半年的**分布式聊天系统**项目，于是有一些些心得想要记录下来。可能会有些又臭又长，想大致了解的话重点看消息加密设计和实现就好了。最后附上项目链接。\n\n<!--more-->\n\n## 设计\n\n聊天系统就是像我们常用的QQ、微信这些。而我们的分布式聊天系统主要包括三个部分：数据库服务端、Web客户端和Android客户端。理想状态下，服务端和Web客户端各部署在独立的两台服务器上，Android客户端则被打包成app安装于用户手机上。但是为了方便合作和互相监管，我们将这三部分分别写作了项目下的三个模块。\n我们主要的通讯思路是服务端和客户端之间通过websocket协议传输json文件，文件包含对数据库读写的请求。具体可以查看我们项目的Wiki，这里就不赘述了。因为我主要负责的是Web客户端的实现，所以这篇文章主要也会详讲这一部分的结构和遇到的问题。如果真的对我们整个系统感兴趣的话，项目库里面也是有具体的报告，在final_report_latex下。\n\n## 需求及功能\n\n### 已实现功能\n- 注册登录\n    注册时检查sql注入，要求密码包含三种类型字符等，如不符合要求将拒绝注册；发送注册请求前对密码进行md5哈希计算，保证服务端无法获取原密码；由于本项目消息加密的实现使得私钥只储存于注册设备，所以目前登录只允许注册账号的设备登录该账号。Web客户端发起登录请求前将首先检查本地内存localStorage是否存在相关私钥（私钥不参与登录验证过程，但是和消息加解密有关）。\n\n- 用户搜索及添加\n    本项目发起聊天不需要经过对方同意，更类似于陌生人聊天室，可以通过搜索功能找到符合搜索关键词模式的所有用户，并生成新的聊天窗口，聊天窗口不会保留至下次登录，聊天记录也不会保存至本地。\n\n- 双方消息加密\n    用户聊天内容的私密性要进行保护。和国内常见聊天软件不一样的是，我们的项目更强调端对端的消息加密和用户的隐私保护，也即服务端无法获取用户实际聊天内容，只储存加密后的消息，并且不直接储存用户密钥。\n\n    我们采用AES+Diffie-Hellman的结合实现信息加密。基本设计是：首先每个用户在新注册时都会本地生成新的密钥对（符合Diffie-Hellman交换规则），并将公钥进行Base64编码发送至服务端保存，这个密钥对将用来计算两方共同密钥 Shared Secret 进行AES的对称加解密。\n\n- 历史记录获取\n    这其实就是一个请求查询数据库的过程，Web端的主要处理是在得到消息后进行解密并根据时间排序以及呈现。这里发生过一个有趣的问题，就是时区的问题，当时我们几个人在不同的地区（一些人由于疫情提前回家了），所以当我们远程连接数据库的时候发现消息时间出现了不一致，也就导致消息展现顺序错乱。后来我们的解决方法也很简单粗暴，就是直接改服务端的系统时间[笑哭.jpg]，毕竟赶时间。当然实际还有更细致的解决方法，我目前能想到的就是直接储存1970年1月1日至今经过的时间数，客户端在接收到时间后再根据系统时区进行转换。\n\n### 可扩展功能\n- 不限字数长度的聊天消息，需要解决数据库储存、JSON请求长度等问题；\n- 消息类型增加emoji、图片、视频和文档；\n- 群组聊天多方加密；\n\n## 加密算法\n\n### AES对称加密\n\n首先大家都知道密码算法按照密钥特点分为两种：对称加密和非对称加密。其中对称加密比较常见的是AES算法和DES算法，非对称加密则是RSA算法和ECC算法。\n\n我们选择对称加密来加解密消息的原因一个是非对称加密的效率比较低下，另一个是一条非对称加密后生成密文只能被接收方解密成明文，就连发送方也无法解密，这会造成历史记录获取失败，除非发送方每次都推一条重复的消息（用自己的公钥加密）到服务端数据库。\n\n说完了选择对称加密的原因，我们再来了解一下AES算法，维基百科里说的很详细这里就不多赘述，简而言之就是一系列不太复杂的逻辑操作但是我脑子记不住。我以前学密码学的时候做过实现AES的Java程序，过不久就忘得一干二净。我觉得大概理解了就差不多了，毕竟我们搞开发又不是做研究，重点还是应该放在API调用上。这里我用的是CryptoJS的AES-256-CBC，其中256指的是单位为bit的密钥长度，CBC是块加密模式。\n\n加密还有一种分法，就是分为流加密和块加密，其中流加密的密钥随机生成并且长度和明文一致，按位（bit）计算，而且为了保证安全性要求密钥每次都不一样的，这显然不能用在我们的项目里；同时AES算法则属于密钥长度确定的块加密，其实不管是流加密还是块加密都要求密钥长度和明文长度一致，但块加密的解决方案是将过长的原文拆分成一块块，每块长度与密钥长度一致，不足的使用一定填充模式进行填充，本项目使用的是Pkcs7填充，CryptoJS默认也是这个模式。\n\n前面提到的CBC (Cipher Book Chaining)则是块加密模式的一种，中文称为密文分组链接模式，块加密模式定义了块之间是如何合作产生最终密文的。在CBC加密模式中，我们要首先定义一个不需要很长的IV (Initialization Vector)初始化向量，这个向量只用一次，就是与第一块明文进行XOR运算，然后用密钥对混淆过的第一块明文进行加密，生成第一块密文，紧接着每块密文又会成为下一块明文的“IV”，直到所有明文块都生成对应的密文块。一般而言每次加密都会生成不一样的IV，使得即便同一段明文也总会生成不一样的密文，防止攻击者使用选择明文攻击法。\n\n### Diffie-Hellman密钥交换协议\n\n前面说到我们用AES对称加密算法来加密消息，但我们发现还有问题，那就是我们要怎么安全地传输对称密钥呢？要怎么储存已生成的对称密钥呢？\n\n那有没有安全的通信通道或者我们用非对称加密对密钥再加密一次？从维基百科的介绍中我们可以大致理解到：目前并没有真正的、第三方无法接触的安全通信通道（也许以后量子网络能做到），都是使用了一些技巧，就像是魔术师的障眼法。后者理论上能阻止第三方得到对称密钥（作为非对称加密的明文），但密钥储存的问题也还是没有解决：因为密钥不能放在服务端的话就只能放在客户端，这就会给客户端造成十分大的压力，尤其是当聊天对象增多以后。\n\n那有没有什么办法能在不安全的通道中安全地传递密钥呢？有人看到这里可能就要说我在想peach或者劝我吃花生米了，但你别说，还真有，就是Diffie-Hellman密钥交换协议。不过如果非要抠字眼的话，这协议并不是传递密钥，而是通过传递中间物进一步计算出密钥（Shared Secret）。\n\n这里我们又要请出我们的老伙计维基百科了，里面用了一个颜料叠加的形象例子，好像中文界面就没有这个图。简单来说，就是Alice和Bob分别用自己的私钥和一个提前约定好的数g进行计算，计算结果告知对方，这个计算结果就是我前面所说的双方传递的中间物。然后双方拿到对方的中间物再和自己的私钥进行计算，这样两个人就能得到一致的结果了，就是Alice.private_key + g + Bob.private_key（这里的+不是四则运算里的加法，其实是mod取余，除数记为p是预先设定好的质数），你会发现这不就是结合律吗？\n\n这个协议要统一g和p这两个数，其中p要是很大的质数，并且这两个数都不是需要保密的对象，也就不用担心泄露。涉及到的计算利用了著名的离散对数问题，也即在知道(a^k) mod p = b这个式子中的a, p, b的时候无法高效计算出k值的问题，当然前提p得是个大质数。\n\n## Web客户端\n\n- JS运行时：Node.js 6.13.4\n- JS框架：Vue 2.6.10 + Element 2.13.0\n- 加密算法库：Diffie-Hellman密钥交换协议（Crypto 1.0.1）; \n- AES对称加密（CryptoJS 2.1.3）\n- 其它：WebSocket\n\nNode.js是异步事件驱动的JavaScript运行时，所谓运行时其实就是程序的依赖库，异步事件就是指被调用的异步函数不管任务是否完成都立即返回，运行的线程不被挂起继续进行下一个语句，而该异步函数完成任务后会进行回调（即通知调用的线程）。提到Node.js又不得不提一下npm (Node Package Manager),这是非常实用的node包管理器，只需要```$ npm install <package-name>```就可以把许多主流的JS依赖包下载到项目中来。\n\nVue提供了响应式和组件化的视图组件，响应式指的是网页在移动设备端打开时可以自适应设备屏幕分辨率和尺寸，优化用户体验；组件化指的是将可能重复出现的视图封装成可重复调用的自定义组件。Vue将组件写成.vue文件，并在上层页面中使用标签进行调用（e.g. 程序员写了一个名为co-example.vue的组件，调用时使用```<co-example></co-example>```）。Element是基于vue的ui库，说实话当时是随便找的，后来才知道是饿了么的UI，总的来说还不错吧，挺多有用的小组件，颜色主题的想法我也挺喜欢的。不过一定要说的话，有一个小问题就是Layout布局中只有列间距没有行间距的参数。\n\n然后是加密算法库。当然了，这个项目肯定不止用了加密算法的库，只不过信息加密是聊天系统十分重要的一点，所以这两个加密算法库就单独拿出来讲讲。我们使用了Diffie-Hellman密钥交换协议和AES对称加密，其中Crypto是Node.js原生库，我们原计划用它来实现加密的整个流程，只是由于某些尚不清楚的原因，Crypto的AES相关函数无法被找到进行调用，不得以我们又用了另一个加密算法库CryptoJS。又因为CryptoJS只实现了加解密算法，并没有实现Diffie-Hellman，我们最终采用了二者共用的策略。密钥交换协议和对称加密这两者在该项目中缺一不可，具体会在后面提到。\n\n“WebSocket是一种网络传输协议，可在单个TCP连接上进行全双工通信，位于OSI模型的应用层”。WebSocket被我们用来进行客户端和服务端之间的通信，因为是全双工，所以两端可以双向同时传输消息，并且建立连接后可以持续通信。","source":"_posts/chat-system-web.md","raw":"---\ntitle: 分布式聊天系统(Web部分)\ndate: 2020-04-22\ncategories: Application\ntags: Web\n---\n\n最近和几个同学刚做完一个为期大半年的**分布式聊天系统**项目，于是有一些些心得想要记录下来。可能会有些又臭又长，想大致了解的话重点看消息加密设计和实现就好了。最后附上项目链接。\n\n<!--more-->\n\n## 设计\n\n聊天系统就是像我们常用的QQ、微信这些。而我们的分布式聊天系统主要包括三个部分：数据库服务端、Web客户端和Android客户端。理想状态下，服务端和Web客户端各部署在独立的两台服务器上，Android客户端则被打包成app安装于用户手机上。但是为了方便合作和互相监管，我们将这三部分分别写作了项目下的三个模块。\n我们主要的通讯思路是服务端和客户端之间通过websocket协议传输json文件，文件包含对数据库读写的请求。具体可以查看我们项目的Wiki，这里就不赘述了。因为我主要负责的是Web客户端的实现，所以这篇文章主要也会详讲这一部分的结构和遇到的问题。如果真的对我们整个系统感兴趣的话，项目库里面也是有具体的报告，在final_report_latex下。\n\n## 需求及功能\n\n### 已实现功能\n- 注册登录\n    注册时检查sql注入，要求密码包含三种类型字符等，如不符合要求将拒绝注册；发送注册请求前对密码进行md5哈希计算，保证服务端无法获取原密码；由于本项目消息加密的实现使得私钥只储存于注册设备，所以目前登录只允许注册账号的设备登录该账号。Web客户端发起登录请求前将首先检查本地内存localStorage是否存在相关私钥（私钥不参与登录验证过程，但是和消息加解密有关）。\n\n- 用户搜索及添加\n    本项目发起聊天不需要经过对方同意，更类似于陌生人聊天室，可以通过搜索功能找到符合搜索关键词模式的所有用户，并生成新的聊天窗口，聊天窗口不会保留至下次登录，聊天记录也不会保存至本地。\n\n- 双方消息加密\n    用户聊天内容的私密性要进行保护。和国内常见聊天软件不一样的是，我们的项目更强调端对端的消息加密和用户的隐私保护，也即服务端无法获取用户实际聊天内容，只储存加密后的消息，并且不直接储存用户密钥。\n\n    我们采用AES+Diffie-Hellman的结合实现信息加密。基本设计是：首先每个用户在新注册时都会本地生成新的密钥对（符合Diffie-Hellman交换规则），并将公钥进行Base64编码发送至服务端保存，这个密钥对将用来计算两方共同密钥 Shared Secret 进行AES的对称加解密。\n\n- 历史记录获取\n    这其实就是一个请求查询数据库的过程，Web端的主要处理是在得到消息后进行解密并根据时间排序以及呈现。这里发生过一个有趣的问题，就是时区的问题，当时我们几个人在不同的地区（一些人由于疫情提前回家了），所以当我们远程连接数据库的时候发现消息时间出现了不一致，也就导致消息展现顺序错乱。后来我们的解决方法也很简单粗暴，就是直接改服务端的系统时间[笑哭.jpg]，毕竟赶时间。当然实际还有更细致的解决方法，我目前能想到的就是直接储存1970年1月1日至今经过的时间数，客户端在接收到时间后再根据系统时区进行转换。\n\n### 可扩展功能\n- 不限字数长度的聊天消息，需要解决数据库储存、JSON请求长度等问题；\n- 消息类型增加emoji、图片、视频和文档；\n- 群组聊天多方加密；\n\n## 加密算法\n\n### AES对称加密\n\n首先大家都知道密码算法按照密钥特点分为两种：对称加密和非对称加密。其中对称加密比较常见的是AES算法和DES算法，非对称加密则是RSA算法和ECC算法。\n\n我们选择对称加密来加解密消息的原因一个是非对称加密的效率比较低下，另一个是一条非对称加密后生成密文只能被接收方解密成明文，就连发送方也无法解密，这会造成历史记录获取失败，除非发送方每次都推一条重复的消息（用自己的公钥加密）到服务端数据库。\n\n说完了选择对称加密的原因，我们再来了解一下AES算法，维基百科里说的很详细这里就不多赘述，简而言之就是一系列不太复杂的逻辑操作但是我脑子记不住。我以前学密码学的时候做过实现AES的Java程序，过不久就忘得一干二净。我觉得大概理解了就差不多了，毕竟我们搞开发又不是做研究，重点还是应该放在API调用上。这里我用的是CryptoJS的AES-256-CBC，其中256指的是单位为bit的密钥长度，CBC是块加密模式。\n\n加密还有一种分法，就是分为流加密和块加密，其中流加密的密钥随机生成并且长度和明文一致，按位（bit）计算，而且为了保证安全性要求密钥每次都不一样的，这显然不能用在我们的项目里；同时AES算法则属于密钥长度确定的块加密，其实不管是流加密还是块加密都要求密钥长度和明文长度一致，但块加密的解决方案是将过长的原文拆分成一块块，每块长度与密钥长度一致，不足的使用一定填充模式进行填充，本项目使用的是Pkcs7填充，CryptoJS默认也是这个模式。\n\n前面提到的CBC (Cipher Book Chaining)则是块加密模式的一种，中文称为密文分组链接模式，块加密模式定义了块之间是如何合作产生最终密文的。在CBC加密模式中，我们要首先定义一个不需要很长的IV (Initialization Vector)初始化向量，这个向量只用一次，就是与第一块明文进行XOR运算，然后用密钥对混淆过的第一块明文进行加密，生成第一块密文，紧接着每块密文又会成为下一块明文的“IV”，直到所有明文块都生成对应的密文块。一般而言每次加密都会生成不一样的IV，使得即便同一段明文也总会生成不一样的密文，防止攻击者使用选择明文攻击法。\n\n### Diffie-Hellman密钥交换协议\n\n前面说到我们用AES对称加密算法来加密消息，但我们发现还有问题，那就是我们要怎么安全地传输对称密钥呢？要怎么储存已生成的对称密钥呢？\n\n那有没有安全的通信通道或者我们用非对称加密对密钥再加密一次？从维基百科的介绍中我们可以大致理解到：目前并没有真正的、第三方无法接触的安全通信通道（也许以后量子网络能做到），都是使用了一些技巧，就像是魔术师的障眼法。后者理论上能阻止第三方得到对称密钥（作为非对称加密的明文），但密钥储存的问题也还是没有解决：因为密钥不能放在服务端的话就只能放在客户端，这就会给客户端造成十分大的压力，尤其是当聊天对象增多以后。\n\n那有没有什么办法能在不安全的通道中安全地传递密钥呢？有人看到这里可能就要说我在想peach或者劝我吃花生米了，但你别说，还真有，就是Diffie-Hellman密钥交换协议。不过如果非要抠字眼的话，这协议并不是传递密钥，而是通过传递中间物进一步计算出密钥（Shared Secret）。\n\n这里我们又要请出我们的老伙计维基百科了，里面用了一个颜料叠加的形象例子，好像中文界面就没有这个图。简单来说，就是Alice和Bob分别用自己的私钥和一个提前约定好的数g进行计算，计算结果告知对方，这个计算结果就是我前面所说的双方传递的中间物。然后双方拿到对方的中间物再和自己的私钥进行计算，这样两个人就能得到一致的结果了，就是Alice.private_key + g + Bob.private_key（这里的+不是四则运算里的加法，其实是mod取余，除数记为p是预先设定好的质数），你会发现这不就是结合律吗？\n\n这个协议要统一g和p这两个数，其中p要是很大的质数，并且这两个数都不是需要保密的对象，也就不用担心泄露。涉及到的计算利用了著名的离散对数问题，也即在知道(a^k) mod p = b这个式子中的a, p, b的时候无法高效计算出k值的问题，当然前提p得是个大质数。\n\n## Web客户端\n\n- JS运行时：Node.js 6.13.4\n- JS框架：Vue 2.6.10 + Element 2.13.0\n- 加密算法库：Diffie-Hellman密钥交换协议（Crypto 1.0.1）; \n- AES对称加密（CryptoJS 2.1.3）\n- 其它：WebSocket\n\nNode.js是异步事件驱动的JavaScript运行时，所谓运行时其实就是程序的依赖库，异步事件就是指被调用的异步函数不管任务是否完成都立即返回，运行的线程不被挂起继续进行下一个语句，而该异步函数完成任务后会进行回调（即通知调用的线程）。提到Node.js又不得不提一下npm (Node Package Manager),这是非常实用的node包管理器，只需要```$ npm install <package-name>```就可以把许多主流的JS依赖包下载到项目中来。\n\nVue提供了响应式和组件化的视图组件，响应式指的是网页在移动设备端打开时可以自适应设备屏幕分辨率和尺寸，优化用户体验；组件化指的是将可能重复出现的视图封装成可重复调用的自定义组件。Vue将组件写成.vue文件，并在上层页面中使用标签进行调用（e.g. 程序员写了一个名为co-example.vue的组件，调用时使用```<co-example></co-example>```）。Element是基于vue的ui库，说实话当时是随便找的，后来才知道是饿了么的UI，总的来说还不错吧，挺多有用的小组件，颜色主题的想法我也挺喜欢的。不过一定要说的话，有一个小问题就是Layout布局中只有列间距没有行间距的参数。\n\n然后是加密算法库。当然了，这个项目肯定不止用了加密算法的库，只不过信息加密是聊天系统十分重要的一点，所以这两个加密算法库就单独拿出来讲讲。我们使用了Diffie-Hellman密钥交换协议和AES对称加密，其中Crypto是Node.js原生库，我们原计划用它来实现加密的整个流程，只是由于某些尚不清楚的原因，Crypto的AES相关函数无法被找到进行调用，不得以我们又用了另一个加密算法库CryptoJS。又因为CryptoJS只实现了加解密算法，并没有实现Diffie-Hellman，我们最终采用了二者共用的策略。密钥交换协议和对称加密这两者在该项目中缺一不可，具体会在后面提到。\n\n“WebSocket是一种网络传输协议，可在单个TCP连接上进行全双工通信，位于OSI模型的应用层”。WebSocket被我们用来进行客户端和服务端之间的通信，因为是全双工，所以两端可以双向同时传输消息，并且建立连接后可以持续通信。","slug":"chat-system-web","published":1,"updated":"2022-02-20T10:10:47.429Z","_id":"ckztkpexk0001xoup674e1919","comments":1,"layout":"post","photos":[],"link":"","content":"<p>最近和几个同学刚做完一个为期大半年的<strong>分布式聊天系统</strong>项目，于是有一些些心得想要记录下来。可能会有些又臭又长，想大致了解的话重点看消息加密设计和实现就好了。最后附上项目链接。</p>\n<span id=\"more\"></span>\n\n<h2 id=\"设计\"><a href=\"#设计\" class=\"headerlink\" title=\"设计\"></a>设计</h2><p>聊天系统就是像我们常用的QQ、微信这些。而我们的分布式聊天系统主要包括三个部分：数据库服务端、Web客户端和Android客户端。理想状态下，服务端和Web客户端各部署在独立的两台服务器上，Android客户端则被打包成app安装于用户手机上。但是为了方便合作和互相监管，我们将这三部分分别写作了项目下的三个模块。<br>我们主要的通讯思路是服务端和客户端之间通过websocket协议传输json文件，文件包含对数据库读写的请求。具体可以查看我们项目的Wiki，这里就不赘述了。因为我主要负责的是Web客户端的实现，所以这篇文章主要也会详讲这一部分的结构和遇到的问题。如果真的对我们整个系统感兴趣的话，项目库里面也是有具体的报告，在final_report_latex下。</p>\n<h2 id=\"需求及功能\"><a href=\"#需求及功能\" class=\"headerlink\" title=\"需求及功能\"></a>需求及功能</h2><h3 id=\"已实现功能\"><a href=\"#已实现功能\" class=\"headerlink\" title=\"已实现功能\"></a>已实现功能</h3><ul>\n<li><p>注册登录<br>  注册时检查sql注入，要求密码包含三种类型字符等，如不符合要求将拒绝注册；发送注册请求前对密码进行md5哈希计算，保证服务端无法获取原密码；由于本项目消息加密的实现使得私钥只储存于注册设备，所以目前登录只允许注册账号的设备登录该账号。Web客户端发起登录请求前将首先检查本地内存localStorage是否存在相关私钥（私钥不参与登录验证过程，但是和消息加解密有关）。</p>\n</li>\n<li><p>用户搜索及添加<br>  本项目发起聊天不需要经过对方同意，更类似于陌生人聊天室，可以通过搜索功能找到符合搜索关键词模式的所有用户，并生成新的聊天窗口，聊天窗口不会保留至下次登录，聊天记录也不会保存至本地。</p>\n</li>\n<li><p>双方消息加密<br>  用户聊天内容的私密性要进行保护。和国内常见聊天软件不一样的是，我们的项目更强调端对端的消息加密和用户的隐私保护，也即服务端无法获取用户实际聊天内容，只储存加密后的消息，并且不直接储存用户密钥。</p>\n<p>  我们采用AES+Diffie-Hellman的结合实现信息加密。基本设计是：首先每个用户在新注册时都会本地生成新的密钥对（符合Diffie-Hellman交换规则），并将公钥进行Base64编码发送至服务端保存，这个密钥对将用来计算两方共同密钥 Shared Secret 进行AES的对称加解密。</p>\n</li>\n<li><p>历史记录获取<br>  这其实就是一个请求查询数据库的过程，Web端的主要处理是在得到消息后进行解密并根据时间排序以及呈现。这里发生过一个有趣的问题，就是时区的问题，当时我们几个人在不同的地区（一些人由于疫情提前回家了），所以当我们远程连接数据库的时候发现消息时间出现了不一致，也就导致消息展现顺序错乱。后来我们的解决方法也很简单粗暴，就是直接改服务端的系统时间[笑哭.jpg]，毕竟赶时间。当然实际还有更细致的解决方法，我目前能想到的就是直接储存1970年1月1日至今经过的时间数，客户端在接收到时间后再根据系统时区进行转换。</p>\n</li>\n</ul>\n<h3 id=\"可扩展功能\"><a href=\"#可扩展功能\" class=\"headerlink\" title=\"可扩展功能\"></a>可扩展功能</h3><ul>\n<li>不限字数长度的聊天消息，需要解决数据库储存、JSON请求长度等问题；</li>\n<li>消息类型增加emoji、图片、视频和文档；</li>\n<li>群组聊天多方加密；</li>\n</ul>\n<h2 id=\"加密算法\"><a href=\"#加密算法\" class=\"headerlink\" title=\"加密算法\"></a>加密算法</h2><h3 id=\"AES对称加密\"><a href=\"#AES对称加密\" class=\"headerlink\" title=\"AES对称加密\"></a>AES对称加密</h3><p>首先大家都知道密码算法按照密钥特点分为两种：对称加密和非对称加密。其中对称加密比较常见的是AES算法和DES算法，非对称加密则是RSA算法和ECC算法。</p>\n<p>我们选择对称加密来加解密消息的原因一个是非对称加密的效率比较低下，另一个是一条非对称加密后生成密文只能被接收方解密成明文，就连发送方也无法解密，这会造成历史记录获取失败，除非发送方每次都推一条重复的消息（用自己的公钥加密）到服务端数据库。</p>\n<p>说完了选择对称加密的原因，我们再来了解一下AES算法，维基百科里说的很详细这里就不多赘述，简而言之就是一系列不太复杂的逻辑操作但是我脑子记不住。我以前学密码学的时候做过实现AES的Java程序，过不久就忘得一干二净。我觉得大概理解了就差不多了，毕竟我们搞开发又不是做研究，重点还是应该放在API调用上。这里我用的是CryptoJS的AES-256-CBC，其中256指的是单位为bit的密钥长度，CBC是块加密模式。</p>\n<p>加密还有一种分法，就是分为流加密和块加密，其中流加密的密钥随机生成并且长度和明文一致，按位（bit）计算，而且为了保证安全性要求密钥每次都不一样的，这显然不能用在我们的项目里；同时AES算法则属于密钥长度确定的块加密，其实不管是流加密还是块加密都要求密钥长度和明文长度一致，但块加密的解决方案是将过长的原文拆分成一块块，每块长度与密钥长度一致，不足的使用一定填充模式进行填充，本项目使用的是Pkcs7填充，CryptoJS默认也是这个模式。</p>\n<p>前面提到的CBC (Cipher Book Chaining)则是块加密模式的一种，中文称为密文分组链接模式，块加密模式定义了块之间是如何合作产生最终密文的。在CBC加密模式中，我们要首先定义一个不需要很长的IV (Initialization Vector)初始化向量，这个向量只用一次，就是与第一块明文进行XOR运算，然后用密钥对混淆过的第一块明文进行加密，生成第一块密文，紧接着每块密文又会成为下一块明文的“IV”，直到所有明文块都生成对应的密文块。一般而言每次加密都会生成不一样的IV，使得即便同一段明文也总会生成不一样的密文，防止攻击者使用选择明文攻击法。</p>\n<h3 id=\"Diffie-Hellman密钥交换协议\"><a href=\"#Diffie-Hellman密钥交换协议\" class=\"headerlink\" title=\"Diffie-Hellman密钥交换协议\"></a>Diffie-Hellman密钥交换协议</h3><p>前面说到我们用AES对称加密算法来加密消息，但我们发现还有问题，那就是我们要怎么安全地传输对称密钥呢？要怎么储存已生成的对称密钥呢？</p>\n<p>那有没有安全的通信通道或者我们用非对称加密对密钥再加密一次？从维基百科的介绍中我们可以大致理解到：目前并没有真正的、第三方无法接触的安全通信通道（也许以后量子网络能做到），都是使用了一些技巧，就像是魔术师的障眼法。后者理论上能阻止第三方得到对称密钥（作为非对称加密的明文），但密钥储存的问题也还是没有解决：因为密钥不能放在服务端的话就只能放在客户端，这就会给客户端造成十分大的压力，尤其是当聊天对象增多以后。</p>\n<p>那有没有什么办法能在不安全的通道中安全地传递密钥呢？有人看到这里可能就要说我在想peach或者劝我吃花生米了，但你别说，还真有，就是Diffie-Hellman密钥交换协议。不过如果非要抠字眼的话，这协议并不是传递密钥，而是通过传递中间物进一步计算出密钥（Shared Secret）。</p>\n<p>这里我们又要请出我们的老伙计维基百科了，里面用了一个颜料叠加的形象例子，好像中文界面就没有这个图。简单来说，就是Alice和Bob分别用自己的私钥和一个提前约定好的数g进行计算，计算结果告知对方，这个计算结果就是我前面所说的双方传递的中间物。然后双方拿到对方的中间物再和自己的私钥进行计算，这样两个人就能得到一致的结果了，就是Alice.private_key + g + Bob.private_key（这里的+不是四则运算里的加法，其实是mod取余，除数记为p是预先设定好的质数），你会发现这不就是结合律吗？</p>\n<p>这个协议要统一g和p这两个数，其中p要是很大的质数，并且这两个数都不是需要保密的对象，也就不用担心泄露。涉及到的计算利用了著名的离散对数问题，也即在知道(a^k) mod p = b这个式子中的a, p, b的时候无法高效计算出k值的问题，当然前提p得是个大质数。</p>\n<h2 id=\"Web客户端\"><a href=\"#Web客户端\" class=\"headerlink\" title=\"Web客户端\"></a>Web客户端</h2><ul>\n<li>JS运行时：Node.js 6.13.4</li>\n<li>JS框架：Vue 2.6.10 + Element 2.13.0</li>\n<li>加密算法库：Diffie-Hellman密钥交换协议（Crypto 1.0.1）; </li>\n<li>AES对称加密（CryptoJS 2.1.3）</li>\n<li>其它：WebSocket</li>\n</ul>\n<p>Node.js是异步事件驱动的JavaScript运行时，所谓运行时其实就是程序的依赖库，异步事件就是指被调用的异步函数不管任务是否完成都立即返回，运行的线程不被挂起继续进行下一个语句，而该异步函数完成任务后会进行回调（即通知调用的线程）。提到Node.js又不得不提一下npm (Node Package Manager),这是非常实用的node包管理器，只需要<code>$ npm install &lt;package-name&gt;</code>就可以把许多主流的JS依赖包下载到项目中来。</p>\n<p>Vue提供了响应式和组件化的视图组件，响应式指的是网页在移动设备端打开时可以自适应设备屏幕分辨率和尺寸，优化用户体验；组件化指的是将可能重复出现的视图封装成可重复调用的自定义组件。Vue将组件写成.vue文件，并在上层页面中使用标签进行调用（e.g. 程序员写了一个名为co-example.vue的组件，调用时使用<code>&lt;co-example&gt;&lt;/co-example&gt;</code>）。Element是基于vue的ui库，说实话当时是随便找的，后来才知道是饿了么的UI，总的来说还不错吧，挺多有用的小组件，颜色主题的想法我也挺喜欢的。不过一定要说的话，有一个小问题就是Layout布局中只有列间距没有行间距的参数。</p>\n<p>然后是加密算法库。当然了，这个项目肯定不止用了加密算法的库，只不过信息加密是聊天系统十分重要的一点，所以这两个加密算法库就单独拿出来讲讲。我们使用了Diffie-Hellman密钥交换协议和AES对称加密，其中Crypto是Node.js原生库，我们原计划用它来实现加密的整个流程，只是由于某些尚不清楚的原因，Crypto的AES相关函数无法被找到进行调用，不得以我们又用了另一个加密算法库CryptoJS。又因为CryptoJS只实现了加解密算法，并没有实现Diffie-Hellman，我们最终采用了二者共用的策略。密钥交换协议和对称加密这两者在该项目中缺一不可，具体会在后面提到。</p>\n<p>“WebSocket是一种网络传输协议，可在单个TCP连接上进行全双工通信，位于OSI模型的应用层”。WebSocket被我们用来进行客户端和服务端之间的通信，因为是全双工，所以两端可以双向同时传输消息，并且建立连接后可以持续通信。</p>\n","site":{"data":{}},"excerpt":"<p>最近和几个同学刚做完一个为期大半年的<strong>分布式聊天系统</strong>项目，于是有一些些心得想要记录下来。可能会有些又臭又长，想大致了解的话重点看消息加密设计和实现就好了。最后附上项目链接。</p>","more":"<h2 id=\"设计\"><a href=\"#设计\" class=\"headerlink\" title=\"设计\"></a>设计</h2><p>聊天系统就是像我们常用的QQ、微信这些。而我们的分布式聊天系统主要包括三个部分：数据库服务端、Web客户端和Android客户端。理想状态下，服务端和Web客户端各部署在独立的两台服务器上，Android客户端则被打包成app安装于用户手机上。但是为了方便合作和互相监管，我们将这三部分分别写作了项目下的三个模块。<br>我们主要的通讯思路是服务端和客户端之间通过websocket协议传输json文件，文件包含对数据库读写的请求。具体可以查看我们项目的Wiki，这里就不赘述了。因为我主要负责的是Web客户端的实现，所以这篇文章主要也会详讲这一部分的结构和遇到的问题。如果真的对我们整个系统感兴趣的话，项目库里面也是有具体的报告，在final_report_latex下。</p>\n<h2 id=\"需求及功能\"><a href=\"#需求及功能\" class=\"headerlink\" title=\"需求及功能\"></a>需求及功能</h2><h3 id=\"已实现功能\"><a href=\"#已实现功能\" class=\"headerlink\" title=\"已实现功能\"></a>已实现功能</h3><ul>\n<li><p>注册登录<br>  注册时检查sql注入，要求密码包含三种类型字符等，如不符合要求将拒绝注册；发送注册请求前对密码进行md5哈希计算，保证服务端无法获取原密码；由于本项目消息加密的实现使得私钥只储存于注册设备，所以目前登录只允许注册账号的设备登录该账号。Web客户端发起登录请求前将首先检查本地内存localStorage是否存在相关私钥（私钥不参与登录验证过程，但是和消息加解密有关）。</p>\n</li>\n<li><p>用户搜索及添加<br>  本项目发起聊天不需要经过对方同意，更类似于陌生人聊天室，可以通过搜索功能找到符合搜索关键词模式的所有用户，并生成新的聊天窗口，聊天窗口不会保留至下次登录，聊天记录也不会保存至本地。</p>\n</li>\n<li><p>双方消息加密<br>  用户聊天内容的私密性要进行保护。和国内常见聊天软件不一样的是，我们的项目更强调端对端的消息加密和用户的隐私保护，也即服务端无法获取用户实际聊天内容，只储存加密后的消息，并且不直接储存用户密钥。</p>\n<p>  我们采用AES+Diffie-Hellman的结合实现信息加密。基本设计是：首先每个用户在新注册时都会本地生成新的密钥对（符合Diffie-Hellman交换规则），并将公钥进行Base64编码发送至服务端保存，这个密钥对将用来计算两方共同密钥 Shared Secret 进行AES的对称加解密。</p>\n</li>\n<li><p>历史记录获取<br>  这其实就是一个请求查询数据库的过程，Web端的主要处理是在得到消息后进行解密并根据时间排序以及呈现。这里发生过一个有趣的问题，就是时区的问题，当时我们几个人在不同的地区（一些人由于疫情提前回家了），所以当我们远程连接数据库的时候发现消息时间出现了不一致，也就导致消息展现顺序错乱。后来我们的解决方法也很简单粗暴，就是直接改服务端的系统时间[笑哭.jpg]，毕竟赶时间。当然实际还有更细致的解决方法，我目前能想到的就是直接储存1970年1月1日至今经过的时间数，客户端在接收到时间后再根据系统时区进行转换。</p>\n</li>\n</ul>\n<h3 id=\"可扩展功能\"><a href=\"#可扩展功能\" class=\"headerlink\" title=\"可扩展功能\"></a>可扩展功能</h3><ul>\n<li>不限字数长度的聊天消息，需要解决数据库储存、JSON请求长度等问题；</li>\n<li>消息类型增加emoji、图片、视频和文档；</li>\n<li>群组聊天多方加密；</li>\n</ul>\n<h2 id=\"加密算法\"><a href=\"#加密算法\" class=\"headerlink\" title=\"加密算法\"></a>加密算法</h2><h3 id=\"AES对称加密\"><a href=\"#AES对称加密\" class=\"headerlink\" title=\"AES对称加密\"></a>AES对称加密</h3><p>首先大家都知道密码算法按照密钥特点分为两种：对称加密和非对称加密。其中对称加密比较常见的是AES算法和DES算法，非对称加密则是RSA算法和ECC算法。</p>\n<p>我们选择对称加密来加解密消息的原因一个是非对称加密的效率比较低下，另一个是一条非对称加密后生成密文只能被接收方解密成明文，就连发送方也无法解密，这会造成历史记录获取失败，除非发送方每次都推一条重复的消息（用自己的公钥加密）到服务端数据库。</p>\n<p>说完了选择对称加密的原因，我们再来了解一下AES算法，维基百科里说的很详细这里就不多赘述，简而言之就是一系列不太复杂的逻辑操作但是我脑子记不住。我以前学密码学的时候做过实现AES的Java程序，过不久就忘得一干二净。我觉得大概理解了就差不多了，毕竟我们搞开发又不是做研究，重点还是应该放在API调用上。这里我用的是CryptoJS的AES-256-CBC，其中256指的是单位为bit的密钥长度，CBC是块加密模式。</p>\n<p>加密还有一种分法，就是分为流加密和块加密，其中流加密的密钥随机生成并且长度和明文一致，按位（bit）计算，而且为了保证安全性要求密钥每次都不一样的，这显然不能用在我们的项目里；同时AES算法则属于密钥长度确定的块加密，其实不管是流加密还是块加密都要求密钥长度和明文长度一致，但块加密的解决方案是将过长的原文拆分成一块块，每块长度与密钥长度一致，不足的使用一定填充模式进行填充，本项目使用的是Pkcs7填充，CryptoJS默认也是这个模式。</p>\n<p>前面提到的CBC (Cipher Book Chaining)则是块加密模式的一种，中文称为密文分组链接模式，块加密模式定义了块之间是如何合作产生最终密文的。在CBC加密模式中，我们要首先定义一个不需要很长的IV (Initialization Vector)初始化向量，这个向量只用一次，就是与第一块明文进行XOR运算，然后用密钥对混淆过的第一块明文进行加密，生成第一块密文，紧接着每块密文又会成为下一块明文的“IV”，直到所有明文块都生成对应的密文块。一般而言每次加密都会生成不一样的IV，使得即便同一段明文也总会生成不一样的密文，防止攻击者使用选择明文攻击法。</p>\n<h3 id=\"Diffie-Hellman密钥交换协议\"><a href=\"#Diffie-Hellman密钥交换协议\" class=\"headerlink\" title=\"Diffie-Hellman密钥交换协议\"></a>Diffie-Hellman密钥交换协议</h3><p>前面说到我们用AES对称加密算法来加密消息，但我们发现还有问题，那就是我们要怎么安全地传输对称密钥呢？要怎么储存已生成的对称密钥呢？</p>\n<p>那有没有安全的通信通道或者我们用非对称加密对密钥再加密一次？从维基百科的介绍中我们可以大致理解到：目前并没有真正的、第三方无法接触的安全通信通道（也许以后量子网络能做到），都是使用了一些技巧，就像是魔术师的障眼法。后者理论上能阻止第三方得到对称密钥（作为非对称加密的明文），但密钥储存的问题也还是没有解决：因为密钥不能放在服务端的话就只能放在客户端，这就会给客户端造成十分大的压力，尤其是当聊天对象增多以后。</p>\n<p>那有没有什么办法能在不安全的通道中安全地传递密钥呢？有人看到这里可能就要说我在想peach或者劝我吃花生米了，但你别说，还真有，就是Diffie-Hellman密钥交换协议。不过如果非要抠字眼的话，这协议并不是传递密钥，而是通过传递中间物进一步计算出密钥（Shared Secret）。</p>\n<p>这里我们又要请出我们的老伙计维基百科了，里面用了一个颜料叠加的形象例子，好像中文界面就没有这个图。简单来说，就是Alice和Bob分别用自己的私钥和一个提前约定好的数g进行计算，计算结果告知对方，这个计算结果就是我前面所说的双方传递的中间物。然后双方拿到对方的中间物再和自己的私钥进行计算，这样两个人就能得到一致的结果了，就是Alice.private_key + g + Bob.private_key（这里的+不是四则运算里的加法，其实是mod取余，除数记为p是预先设定好的质数），你会发现这不就是结合律吗？</p>\n<p>这个协议要统一g和p这两个数，其中p要是很大的质数，并且这两个数都不是需要保密的对象，也就不用担心泄露。涉及到的计算利用了著名的离散对数问题，也即在知道(a^k) mod p = b这个式子中的a, p, b的时候无法高效计算出k值的问题，当然前提p得是个大质数。</p>\n<h2 id=\"Web客户端\"><a href=\"#Web客户端\" class=\"headerlink\" title=\"Web客户端\"></a>Web客户端</h2><ul>\n<li>JS运行时：Node.js 6.13.4</li>\n<li>JS框架：Vue 2.6.10 + Element 2.13.0</li>\n<li>加密算法库：Diffie-Hellman密钥交换协议（Crypto 1.0.1）; </li>\n<li>AES对称加密（CryptoJS 2.1.3）</li>\n<li>其它：WebSocket</li>\n</ul>\n<p>Node.js是异步事件驱动的JavaScript运行时，所谓运行时其实就是程序的依赖库，异步事件就是指被调用的异步函数不管任务是否完成都立即返回，运行的线程不被挂起继续进行下一个语句，而该异步函数完成任务后会进行回调（即通知调用的线程）。提到Node.js又不得不提一下npm (Node Package Manager),这是非常实用的node包管理器，只需要<code>$ npm install &lt;package-name&gt;</code>就可以把许多主流的JS依赖包下载到项目中来。</p>\n<p>Vue提供了响应式和组件化的视图组件，响应式指的是网页在移动设备端打开时可以自适应设备屏幕分辨率和尺寸，优化用户体验；组件化指的是将可能重复出现的视图封装成可重复调用的自定义组件。Vue将组件写成.vue文件，并在上层页面中使用标签进行调用（e.g. 程序员写了一个名为co-example.vue的组件，调用时使用<code>&lt;co-example&gt;&lt;/co-example&gt;</code>）。Element是基于vue的ui库，说实话当时是随便找的，后来才知道是饿了么的UI，总的来说还不错吧，挺多有用的小组件，颜色主题的想法我也挺喜欢的。不过一定要说的话，有一个小问题就是Layout布局中只有列间距没有行间距的参数。</p>\n<p>然后是加密算法库。当然了，这个项目肯定不止用了加密算法的库，只不过信息加密是聊天系统十分重要的一点，所以这两个加密算法库就单独拿出来讲讲。我们使用了Diffie-Hellman密钥交换协议和AES对称加密，其中Crypto是Node.js原生库，我们原计划用它来实现加密的整个流程，只是由于某些尚不清楚的原因，Crypto的AES相关函数无法被找到进行调用，不得以我们又用了另一个加密算法库CryptoJS。又因为CryptoJS只实现了加解密算法，并没有实现Diffie-Hellman，我们最终采用了二者共用的策略。密钥交换协议和对称加密这两者在该项目中缺一不可，具体会在后面提到。</p>\n<p>“WebSocket是一种网络传输协议，可在单个TCP连接上进行全双工通信，位于OSI模型的应用层”。WebSocket被我们用来进行客户端和服务端之间的通信，因为是全双工，所以两端可以双向同时传输消息，并且建立连接后可以持续通信。</p>"},{"title":"计算机网络基础","date":"2020-04-27T16:00:00.000Z","_content":"\n> _A **computer network** is a set of computers sharing resources located on or provided by network nodes. The computers use common communication protocols over digital interconnections to communicate with each other._\n\n<!--more-->\n\n## OSI 七层网络结构 (Open Systems Interconnection Model)\n7、应用层 (Application Layer)\n\n6、表示层 (Presentation Layer)\n\n5、会话层 (Session Layer)\n\n4、传输层 (Transport Layer)\n\n3、网络层 (Network Layer)\n\n2、数据链路层 (Data Link Layer)\n\n1、物理层 (Physical Layer)\n\n## 常见网络协议\nHTTP (Hyper Text Transfer Protocol) 超文本协议\n应用层，基于TCP/IP。\n\nPOP3 (Post Office Protocol version 3) 邮局协议第三版\nRFC 1939定义。应用层。\n\nIPv4 (Internet Protocol version 4) 互联网通信协议第四版\nRFC 791定义。网络层，无连接的协议。\n\n## IP分类\nIP地址=网络号+主机号，分为A、B、C三类及特殊地址D、E。\n\nA类\n32位地址中第一位必须为0，前一个字节为网络号\n地址范围：1.0.0.1-126.255.255.254\n默认子网掩码：255.0.0.0\n\nB类\n32位地址中前两位必须为10，前两个字节为网络号\n地址范围：128.0.0.1-191.255.255.254\n默认子网掩码：255.255.0.0\n\nC类\n32位地址中前三位必须为110，前三个字节为网络号\n地址范围：192.0.0.1-.223.255.254\n默认子网掩码：255.255.255.0\n\nD类（多播地址）\n32位地址中前四位必须为1110\n地址范围：224.0.0.1-239.255.255.254\n\nE类（保留地址）\n32位地址中前4为必须为1111\n地址范围：240.0.0.1-255.255.255.254\n\n回送地址\n地址范围：127.0.0.1-127.255.255.254","source":"_posts/computer-network-basics.md","raw":"---\ntitle: 计算机网络基础\ndate: 2020-04-28\ncategories: Computer Network\ntags: Computer Network\n---\n\n> _A **computer network** is a set of computers sharing resources located on or provided by network nodes. The computers use common communication protocols over digital interconnections to communicate with each other._\n\n<!--more-->\n\n## OSI 七层网络结构 (Open Systems Interconnection Model)\n7、应用层 (Application Layer)\n\n6、表示层 (Presentation Layer)\n\n5、会话层 (Session Layer)\n\n4、传输层 (Transport Layer)\n\n3、网络层 (Network Layer)\n\n2、数据链路层 (Data Link Layer)\n\n1、物理层 (Physical Layer)\n\n## 常见网络协议\nHTTP (Hyper Text Transfer Protocol) 超文本协议\n应用层，基于TCP/IP。\n\nPOP3 (Post Office Protocol version 3) 邮局协议第三版\nRFC 1939定义。应用层。\n\nIPv4 (Internet Protocol version 4) 互联网通信协议第四版\nRFC 791定义。网络层，无连接的协议。\n\n## IP分类\nIP地址=网络号+主机号，分为A、B、C三类及特殊地址D、E。\n\nA类\n32位地址中第一位必须为0，前一个字节为网络号\n地址范围：1.0.0.1-126.255.255.254\n默认子网掩码：255.0.0.0\n\nB类\n32位地址中前两位必须为10，前两个字节为网络号\n地址范围：128.0.0.1-191.255.255.254\n默认子网掩码：255.255.0.0\n\nC类\n32位地址中前三位必须为110，前三个字节为网络号\n地址范围：192.0.0.1-.223.255.254\n默认子网掩码：255.255.255.0\n\nD类（多播地址）\n32位地址中前四位必须为1110\n地址范围：224.0.0.1-239.255.255.254\n\nE类（保留地址）\n32位地址中前4为必须为1111\n地址范围：240.0.0.1-255.255.255.254\n\n回送地址\n地址范围：127.0.0.1-127.255.255.254","slug":"computer-network-basics","published":1,"updated":"2022-02-20T10:14:41.547Z","_id":"ckztkpexl0003xoup8pm275oy","comments":1,"layout":"post","photos":[],"link":"","content":"<blockquote>\n<p><em>A <strong>computer network</strong> is a set of computers sharing resources located on or provided by network nodes. The computers use common communication protocols over digital interconnections to communicate with each other.</em></p>\n</blockquote>\n<span id=\"more\"></span>\n\n<h2 id=\"OSI-七层网络结构-Open-Systems-Interconnection-Model\"><a href=\"#OSI-七层网络结构-Open-Systems-Interconnection-Model\" class=\"headerlink\" title=\"OSI 七层网络结构 (Open Systems Interconnection Model)\"></a>OSI 七层网络结构 (Open Systems Interconnection Model)</h2><p>7、应用层 (Application Layer)</p>\n<p>6、表示层 (Presentation Layer)</p>\n<p>5、会话层 (Session Layer)</p>\n<p>4、传输层 (Transport Layer)</p>\n<p>3、网络层 (Network Layer)</p>\n<p>2、数据链路层 (Data Link Layer)</p>\n<p>1、物理层 (Physical Layer)</p>\n<h2 id=\"常见网络协议\"><a href=\"#常见网络协议\" class=\"headerlink\" title=\"常见网络协议\"></a>常见网络协议</h2><p>HTTP (Hyper Text Transfer Protocol) 超文本协议<br>应用层，基于TCP/IP。</p>\n<p>POP3 (Post Office Protocol version 3) 邮局协议第三版<br>RFC 1939定义。应用层。</p>\n<p>IPv4 (Internet Protocol version 4) 互联网通信协议第四版<br>RFC 791定义。网络层，无连接的协议。</p>\n<h2 id=\"IP分类\"><a href=\"#IP分类\" class=\"headerlink\" title=\"IP分类\"></a>IP分类</h2><p>IP地址=网络号+主机号，分为A、B、C三类及特殊地址D、E。</p>\n<p>A类<br>32位地址中第一位必须为0，前一个字节为网络号<br>地址范围：1.0.0.1-126.255.255.254<br>默认子网掩码：255.0.0.0</p>\n<p>B类<br>32位地址中前两位必须为10，前两个字节为网络号<br>地址范围：128.0.0.1-191.255.255.254<br>默认子网掩码：255.255.0.0</p>\n<p>C类<br>32位地址中前三位必须为110，前三个字节为网络号<br>地址范围：192.0.0.1-.223.255.254<br>默认子网掩码：255.255.255.0</p>\n<p>D类（多播地址）<br>32位地址中前四位必须为1110<br>地址范围：224.0.0.1-239.255.255.254</p>\n<p>E类（保留地址）<br>32位地址中前4为必须为1111<br>地址范围：240.0.0.1-255.255.255.254</p>\n<p>回送地址<br>地址范围：127.0.0.1-127.255.255.254</p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p><em>A <strong>computer network</strong> is a set of computers sharing resources located on or provided by network nodes. The computers use common communication protocols over digital interconnections to communicate with each other.</em></p>\n</blockquote>","more":"<h2 id=\"OSI-七层网络结构-Open-Systems-Interconnection-Model\"><a href=\"#OSI-七层网络结构-Open-Systems-Interconnection-Model\" class=\"headerlink\" title=\"OSI 七层网络结构 (Open Systems Interconnection Model)\"></a>OSI 七层网络结构 (Open Systems Interconnection Model)</h2><p>7、应用层 (Application Layer)</p>\n<p>6、表示层 (Presentation Layer)</p>\n<p>5、会话层 (Session Layer)</p>\n<p>4、传输层 (Transport Layer)</p>\n<p>3、网络层 (Network Layer)</p>\n<p>2、数据链路层 (Data Link Layer)</p>\n<p>1、物理层 (Physical Layer)</p>\n<h2 id=\"常见网络协议\"><a href=\"#常见网络协议\" class=\"headerlink\" title=\"常见网络协议\"></a>常见网络协议</h2><p>HTTP (Hyper Text Transfer Protocol) 超文本协议<br>应用层，基于TCP/IP。</p>\n<p>POP3 (Post Office Protocol version 3) 邮局协议第三版<br>RFC 1939定义。应用层。</p>\n<p>IPv4 (Internet Protocol version 4) 互联网通信协议第四版<br>RFC 791定义。网络层，无连接的协议。</p>\n<h2 id=\"IP分类\"><a href=\"#IP分类\" class=\"headerlink\" title=\"IP分类\"></a>IP分类</h2><p>IP地址=网络号+主机号，分为A、B、C三类及特殊地址D、E。</p>\n<p>A类<br>32位地址中第一位必须为0，前一个字节为网络号<br>地址范围：1.0.0.1-126.255.255.254<br>默认子网掩码：255.0.0.0</p>\n<p>B类<br>32位地址中前两位必须为10，前两个字节为网络号<br>地址范围：128.0.0.1-191.255.255.254<br>默认子网掩码：255.255.0.0</p>\n<p>C类<br>32位地址中前三位必须为110，前三个字节为网络号<br>地址范围：192.0.0.1-.223.255.254<br>默认子网掩码：255.255.255.0</p>\n<p>D类（多播地址）<br>32位地址中前四位必须为1110<br>地址范围：224.0.0.1-239.255.255.254</p>\n<p>E类（保留地址）<br>32位地址中前4为必须为1111<br>地址范围：240.0.0.1-255.255.255.254</p>\n<p>回送地址<br>地址范围：127.0.0.1-127.255.255.254</p>"},{"title":"Git常用命令","date":"2018-11-06T16:00:00.000Z","_content":"\n> **Git** is a free and open source distributed version control system designed to handle everything from small to very large projects with speed and efficiency.\n\n<!--more-->\n\n以下命令中，origin常用作远程版本库名，master则为主要分支名。\n\n## 本地创建版本库\n新建一个空文件夹，在该路径下打开bash并输入命令$ git init，将生成一个.git隐藏文件。\n\n## add&commit\n```$ git add <file>```\n```$ git commit -m <message>```\n\n## 添加远程版本库\n```$ git remote add orign <URL>```\n\n## 查看关联远程版本库\n```$ git remote```\n\n## 更新远程版本库版本信息到本地\n```$ git fetch```\n\n## 同步远程版本库到本地\n```$ git pull -u origin master```\n\n## 同步本地版本库到远程\n```$ git push -u origin master```\n\n## 克隆远程版本库到本地（在此基础上push则无须添加远程版本库）\n```$ git clone <URL>（等效于 init+remote add+pull）```\n\n## 新建及更换分支（本地）\n```$ git checkout -b <branch>```\n\n## 合并分支到目前工作分支\n```$ git merge <branch-to-be-merged>```\n\n## 版本回退\n```$ git reset [option] <head> ([option]=[–soft | –hard | –mixed]) ```\n\n## 版本恢复（错误回退后恢复到未来版本）\n```$ git reflog```查看最近版本信息+版本回退","source":"_posts/git-command.md","raw":"---\ntitle: Git常用命令\ndate: 2018-11-07\ncategories: Command\ntags: Git\n---\n\n> **Git** is a free and open source distributed version control system designed to handle everything from small to very large projects with speed and efficiency.\n\n<!--more-->\n\n以下命令中，origin常用作远程版本库名，master则为主要分支名。\n\n## 本地创建版本库\n新建一个空文件夹，在该路径下打开bash并输入命令$ git init，将生成一个.git隐藏文件。\n\n## add&commit\n```$ git add <file>```\n```$ git commit -m <message>```\n\n## 添加远程版本库\n```$ git remote add orign <URL>```\n\n## 查看关联远程版本库\n```$ git remote```\n\n## 更新远程版本库版本信息到本地\n```$ git fetch```\n\n## 同步远程版本库到本地\n```$ git pull -u origin master```\n\n## 同步本地版本库到远程\n```$ git push -u origin master```\n\n## 克隆远程版本库到本地（在此基础上push则无须添加远程版本库）\n```$ git clone <URL>（等效于 init+remote add+pull）```\n\n## 新建及更换分支（本地）\n```$ git checkout -b <branch>```\n\n## 合并分支到目前工作分支\n```$ git merge <branch-to-be-merged>```\n\n## 版本回退\n```$ git reset [option] <head> ([option]=[–soft | –hard | –mixed]) ```\n\n## 版本恢复（错误回退后恢复到未来版本）\n```$ git reflog```查看最近版本信息+版本回退","slug":"git-command","published":1,"updated":"2022-02-20T10:10:59.207Z","_id":"ckztkpexm0005xoupcbx12fdd","comments":1,"layout":"post","photos":[],"link":"","content":"<blockquote>\n<p><strong>Git</strong> is a free and open source distributed version control system designed to handle everything from small to very large projects with speed and efficiency.</p>\n</blockquote>\n<span id=\"more\"></span>\n\n<p>以下命令中，origin常用作远程版本库名，master则为主要分支名。</p>\n<h2 id=\"本地创建版本库\"><a href=\"#本地创建版本库\" class=\"headerlink\" title=\"本地创建版本库\"></a>本地创建版本库</h2><p>新建一个空文件夹，在该路径下打开bash并输入命令$ git init，将生成一个.git隐藏文件。</p>\n<h2 id=\"add-amp-commit\"><a href=\"#add-amp-commit\" class=\"headerlink\" title=\"add&amp;commit\"></a>add&amp;commit</h2><p><code>$ git add &lt;file&gt;</code><br><code>$ git commit -m &lt;message&gt;</code></p>\n<h2 id=\"添加远程版本库\"><a href=\"#添加远程版本库\" class=\"headerlink\" title=\"添加远程版本库\"></a>添加远程版本库</h2><p><code>$ git remote add orign &lt;URL&gt;</code></p>\n<h2 id=\"查看关联远程版本库\"><a href=\"#查看关联远程版本库\" class=\"headerlink\" title=\"查看关联远程版本库\"></a>查看关联远程版本库</h2><p><code>$ git remote</code></p>\n<h2 id=\"更新远程版本库版本信息到本地\"><a href=\"#更新远程版本库版本信息到本地\" class=\"headerlink\" title=\"更新远程版本库版本信息到本地\"></a>更新远程版本库版本信息到本地</h2><p><code>$ git fetch</code></p>\n<h2 id=\"同步远程版本库到本地\"><a href=\"#同步远程版本库到本地\" class=\"headerlink\" title=\"同步远程版本库到本地\"></a>同步远程版本库到本地</h2><p><code>$ git pull -u origin master</code></p>\n<h2 id=\"同步本地版本库到远程\"><a href=\"#同步本地版本库到远程\" class=\"headerlink\" title=\"同步本地版本库到远程\"></a>同步本地版本库到远程</h2><p><code>$ git push -u origin master</code></p>\n<h2 id=\"克隆远程版本库到本地（在此基础上push则无须添加远程版本库）\"><a href=\"#克隆远程版本库到本地（在此基础上push则无须添加远程版本库）\" class=\"headerlink\" title=\"克隆远程版本库到本地（在此基础上push则无须添加远程版本库）\"></a>克隆远程版本库到本地（在此基础上push则无须添加远程版本库）</h2><p><code>$ git clone &lt;URL&gt;（等效于 init+remote add+pull）</code></p>\n<h2 id=\"新建及更换分支（本地）\"><a href=\"#新建及更换分支（本地）\" class=\"headerlink\" title=\"新建及更换分支（本地）\"></a>新建及更换分支（本地）</h2><p><code>$ git checkout -b &lt;branch&gt;</code></p>\n<h2 id=\"合并分支到目前工作分支\"><a href=\"#合并分支到目前工作分支\" class=\"headerlink\" title=\"合并分支到目前工作分支\"></a>合并分支到目前工作分支</h2><p><code>$ git merge &lt;branch-to-be-merged&gt;</code></p>\n<h2 id=\"版本回退\"><a href=\"#版本回退\" class=\"headerlink\" title=\"版本回退\"></a>版本回退</h2><p><code>$ git reset [option] &lt;head&gt; ([option]=[–soft | –hard | –mixed]) </code></p>\n<h2 id=\"版本恢复（错误回退后恢复到未来版本）\"><a href=\"#版本恢复（错误回退后恢复到未来版本）\" class=\"headerlink\" title=\"版本恢复（错误回退后恢复到未来版本）\"></a>版本恢复（错误回退后恢复到未来版本）</h2><p><code>$ git reflog</code>查看最近版本信息+版本回退</p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p><strong>Git</strong> is a free and open source distributed version control system designed to handle everything from small to very large projects with speed and efficiency.</p>\n</blockquote>","more":"<p>以下命令中，origin常用作远程版本库名，master则为主要分支名。</p>\n<h2 id=\"本地创建版本库\"><a href=\"#本地创建版本库\" class=\"headerlink\" title=\"本地创建版本库\"></a>本地创建版本库</h2><p>新建一个空文件夹，在该路径下打开bash并输入命令$ git init，将生成一个.git隐藏文件。</p>\n<h2 id=\"add-amp-commit\"><a href=\"#add-amp-commit\" class=\"headerlink\" title=\"add&amp;commit\"></a>add&amp;commit</h2><p><code>$ git add &lt;file&gt;</code><br><code>$ git commit -m &lt;message&gt;</code></p>\n<h2 id=\"添加远程版本库\"><a href=\"#添加远程版本库\" class=\"headerlink\" title=\"添加远程版本库\"></a>添加远程版本库</h2><p><code>$ git remote add orign &lt;URL&gt;</code></p>\n<h2 id=\"查看关联远程版本库\"><a href=\"#查看关联远程版本库\" class=\"headerlink\" title=\"查看关联远程版本库\"></a>查看关联远程版本库</h2><p><code>$ git remote</code></p>\n<h2 id=\"更新远程版本库版本信息到本地\"><a href=\"#更新远程版本库版本信息到本地\" class=\"headerlink\" title=\"更新远程版本库版本信息到本地\"></a>更新远程版本库版本信息到本地</h2><p><code>$ git fetch</code></p>\n<h2 id=\"同步远程版本库到本地\"><a href=\"#同步远程版本库到本地\" class=\"headerlink\" title=\"同步远程版本库到本地\"></a>同步远程版本库到本地</h2><p><code>$ git pull -u origin master</code></p>\n<h2 id=\"同步本地版本库到远程\"><a href=\"#同步本地版本库到远程\" class=\"headerlink\" title=\"同步本地版本库到远程\"></a>同步本地版本库到远程</h2><p><code>$ git push -u origin master</code></p>\n<h2 id=\"克隆远程版本库到本地（在此基础上push则无须添加远程版本库）\"><a href=\"#克隆远程版本库到本地（在此基础上push则无须添加远程版本库）\" class=\"headerlink\" title=\"克隆远程版本库到本地（在此基础上push则无须添加远程版本库）\"></a>克隆远程版本库到本地（在此基础上push则无须添加远程版本库）</h2><p><code>$ git clone &lt;URL&gt;（等效于 init+remote add+pull）</code></p>\n<h2 id=\"新建及更换分支（本地）\"><a href=\"#新建及更换分支（本地）\" class=\"headerlink\" title=\"新建及更换分支（本地）\"></a>新建及更换分支（本地）</h2><p><code>$ git checkout -b &lt;branch&gt;</code></p>\n<h2 id=\"合并分支到目前工作分支\"><a href=\"#合并分支到目前工作分支\" class=\"headerlink\" title=\"合并分支到目前工作分支\"></a>合并分支到目前工作分支</h2><p><code>$ git merge &lt;branch-to-be-merged&gt;</code></p>\n<h2 id=\"版本回退\"><a href=\"#版本回退\" class=\"headerlink\" title=\"版本回退\"></a>版本回退</h2><p><code>$ git reset [option] &lt;head&gt; ([option]=[–soft | –hard | –mixed]) </code></p>\n<h2 id=\"版本恢复（错误回退后恢复到未来版本）\"><a href=\"#版本恢复（错误回退后恢复到未来版本）\" class=\"headerlink\" title=\"版本恢复（错误回退后恢复到未来版本）\"></a>版本恢复（错误回退后恢复到未来版本）</h2><p><code>$ git reflog</code>查看最近版本信息+版本回退</p>"},{"title":"Linux常用指令","date":"2020-04-27T16:00:00.000Z","_content":"\n> _**Linux** is a family of open-source Unix-like operating systems based on the Linux kernel, an operating system kernel first released on September 17, 1991, by Linus Torvalds._\n\n<!--more-->\n\n## 解压缩\n.tar\n```$ tar -xvf <file_name>.tar```\n```$ tar -cvf <file_name>.tar <directory_name>```\n\n.gz\ntar -xzf <file_name>.gz\ntar -czf <file_name>.gz <directory_name>\n\n.tar.gz\ngzip / gunzip\n\n.rar\nunrar\n\n.zip\nunzip\n\n## 修改文件操作权限\n$ chmod\n\n数字设定：4r 2w 1x, e.g. $ chmod 777 a.exe\n符号设定：u拥有者 g所属群组 o其他人 a所有人 +添加 -移除 =设定 r读 w写 x执行，e.g. $chmod a+x, g+w a.exe\n\n## 查看文件\ncat 跳到最后一页\nmore 回车可翻页\nless 光标上下浏览\n\n## 输出当前路径\n$ pwd (print working directory)","source":"_posts/linux-command.md","raw":"---\ntitle: Linux常用指令\ndate: 2020-04-28\ncategories: Command\ntags: Linux\n---\n\n> _**Linux** is a family of open-source Unix-like operating systems based on the Linux kernel, an operating system kernel first released on September 17, 1991, by Linus Torvalds._\n\n<!--more-->\n\n## 解压缩\n.tar\n```$ tar -xvf <file_name>.tar```\n```$ tar -cvf <file_name>.tar <directory_name>```\n\n.gz\ntar -xzf <file_name>.gz\ntar -czf <file_name>.gz <directory_name>\n\n.tar.gz\ngzip / gunzip\n\n.rar\nunrar\n\n.zip\nunzip\n\n## 修改文件操作权限\n$ chmod\n\n数字设定：4r 2w 1x, e.g. $ chmod 777 a.exe\n符号设定：u拥有者 g所属群组 o其他人 a所有人 +添加 -移除 =设定 r读 w写 x执行，e.g. $chmod a+x, g+w a.exe\n\n## 查看文件\ncat 跳到最后一页\nmore 回车可翻页\nless 光标上下浏览\n\n## 输出当前路径\n$ pwd (print working directory)","slug":"linux-command","published":1,"updated":"2022-02-20T10:14:54.338Z","_id":"ckztkpexp000axoup2ai441au","comments":1,"layout":"post","photos":[],"link":"","content":"<blockquote>\n<p><em><strong>Linux</strong> is a family of open-source Unix-like operating systems based on the Linux kernel, an operating system kernel first released on September 17, 1991, by Linus Torvalds.</em></p>\n</blockquote>\n<span id=\"more\"></span>\n\n<h2 id=\"解压缩\"><a href=\"#解压缩\" class=\"headerlink\" title=\"解压缩\"></a>解压缩</h2><p>.tar<br><code>$ tar -xvf &lt;file_name&gt;.tar</code><br><code>$ tar -cvf &lt;file_name&gt;.tar &lt;directory_name&gt;</code></p>\n<p>.gz<br>tar -xzf <file_name>.gz<br>tar -czf <file_name>.gz <directory_name></p>\n<p>.tar.gz<br>gzip / gunzip</p>\n<p>.rar<br>unrar</p>\n<p>.zip<br>unzip</p>\n<h2 id=\"修改文件操作权限\"><a href=\"#修改文件操作权限\" class=\"headerlink\" title=\"修改文件操作权限\"></a>修改文件操作权限</h2><p>$ chmod</p>\n<p>数字设定：4r 2w 1x, e.g. $ chmod 777 a.exe<br>符号设定：u拥有者 g所属群组 o其他人 a所有人 +添加 -移除 =设定 r读 w写 x执行，e.g. $chmod a+x, g+w a.exe</p>\n<h2 id=\"查看文件\"><a href=\"#查看文件\" class=\"headerlink\" title=\"查看文件\"></a>查看文件</h2><p>cat 跳到最后一页<br>more 回车可翻页<br>less 光标上下浏览</p>\n<h2 id=\"输出当前路径\"><a href=\"#输出当前路径\" class=\"headerlink\" title=\"输出当前路径\"></a>输出当前路径</h2><p>$ pwd (print working directory)</p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p><em><strong>Linux</strong> is a family of open-source Unix-like operating systems based on the Linux kernel, an operating system kernel first released on September 17, 1991, by Linus Torvalds.</em></p>\n</blockquote>","more":"<h2 id=\"解压缩\"><a href=\"#解压缩\" class=\"headerlink\" title=\"解压缩\"></a>解压缩</h2><p>.tar<br><code>$ tar -xvf &lt;file_name&gt;.tar</code><br><code>$ tar -cvf &lt;file_name&gt;.tar &lt;directory_name&gt;</code></p>\n<p>.gz<br>tar -xzf <file_name>.gz<br>tar -czf <file_name>.gz <directory_name></p>\n<p>.tar.gz<br>gzip / gunzip</p>\n<p>.rar<br>unrar</p>\n<p>.zip<br>unzip</p>\n<h2 id=\"修改文件操作权限\"><a href=\"#修改文件操作权限\" class=\"headerlink\" title=\"修改文件操作权限\"></a>修改文件操作权限</h2><p>$ chmod</p>\n<p>数字设定：4r 2w 1x, e.g. $ chmod 777 a.exe<br>符号设定：u拥有者 g所属群组 o其他人 a所有人 +添加 -移除 =设定 r读 w写 x执行，e.g. $chmod a+x, g+w a.exe</p>\n<h2 id=\"查看文件\"><a href=\"#查看文件\" class=\"headerlink\" title=\"查看文件\"></a>查看文件</h2><p>cat 跳到最后一页<br>more 回车可翻页<br>less 光标上下浏览</p>\n<h2 id=\"输出当前路径\"><a href=\"#输出当前路径\" class=\"headerlink\" title=\"输出当前路径\"></a>输出当前路径</h2><p>$ pwd (print working directory)</p>"},{"title":"剑指Offer面试题3：数组中重复的数字","date":"2022-02-19T08:20:20.000Z","toc":true,"_content":"\n**数组**是占据一块连续内容并按照顺序存储数据的数据结构。创建数组需要先指定数组的容量大小，然后根据大小分配内存，因此空间效率不高，经常会有空闲的区域。由于数组中的内存是连续的，可以根据下标在O(1)时间读写任何元素，所以它的时间效率很高。\n\n<!--more-->\n\n</br>\n</br>\n</br>\n\n## 题目一：找出数组中重复的数字\n\n|在一个长度为n的数组里的所有数字都在0\\~n-1的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。例如，如果输入长度为7的数组{2, 3, 1, 0, 2, 5, 3}，那么对应的输出是重复的数字2或3。</br>LeetCode力扣链接：[https://leetcode-cn.com/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof/]|\n|---|\n||\n\n这道题有两个简单的题解：\n1. 将数组排序，然后遍历找出与前一元素相同的数组元素即可。排序需要O(nlogn)的时间复杂度，遍历一遍需要O(n)，所以总的时间复杂度为O(nlogn + n)。\n2. 利用哈希表在遍历数组过程中映射数组元素的存在情况：创建一个哈希表，然后遍历原数组，每当出现一个新数字的时候就把它加入到哈希表里。这种算法的时间复杂度为O(n)，但是由于创建了哈希表，所以还有空间复杂度为O(n)。\n        \n但是，还有没有不需要创建新的内存空间的算法呢？\n\n### 思路\n\n我们已知数字都在0\\~n-1的范围内，这意味着将数字从小到大排序后每个数组元素的下标将会和数字相等。利用这个特性，我们可以准确找出每个数字应该存在的位置，如果在排序过程中发现该位置已经被对应数字占用了，那么我们就可以知道这是重复数字了。由于不能创建新对象，我们在将数字归位的时候只能将其与取出的数字进行位置交换。如此一来，只要完整遍历一次数组就能找出重复数字了。\n\n### 举例\n\n以题目中的{2, 3, 1, 0, 2, 5, 3}为例，我们从第一个元素开始遍历。第一个元素是nums[0]=2，应该放在nums[2]=1的位置，我们交换两者的位置后使得nums[0]=1，由于nums[0]里的数字不应该为1，我们要继续帮1找位置；我们将num[1]=3和nums[0]=1进行交换，得到nums[0]=3；继续帮3找位置，将nums[0]=3和nums[3]=0找位置，得到nums[0]=0；由于0的位置正确，这时我们就可以看下一个元素，现在的数组是{0, 1, 2, 3, 2, 5, 3}；我们遍历了nums[1]、nums[2]、nums[3]发现数字都是正确的，直到nums[4]=2；我们像之前一样帮2找位置，这时我们又发现nums[2]=2，也即位置被正确数字占用，意味着出现重复数字，于是我们可以跳出遍历返回该重复数字。\n\n### 原文代码(C/C++)\n\nhttps://github.com/zhedahht/CodingInterviewChinese2/blob/master/03_01_DuplicationInArray/FindDuplication.cpp\n\n### 个人编写代码(C#)\n\n```\npublic int FindRepeatNumber(int[] nums)\n{\n    if (nums != null && nums.Length > 1)\n    {\n        for (int i = 0; i < nums.Length; ++i)\n        {\n            if (nums[i] < 0 || nums[i] > nums.Length -1)\n            {\n                return -1;\n            }\n        }\n\n        for (int i = 0; i < nums.Length; ++i)\n        {\n            while (nums[i] != i)\n            {\n                if (nums[i] == nums[nums[i]])\n                {\n                    return nums[i];\n                }\n\n                int temp = nums[i];\n                nums[i] = nums[nums[i]];\n                nums[temp] = temp;\n            }\n        }\n    }\n\n    return -1;\n}\n```\n\n## 题目二：不修改数组找出重复的数字\n\n|在一个长度为n+1的数组里的所有数字都在1\\~n的范围内，所以数组中至少有一个数字是重复的。请找出数组中任意一个重复的数字，但不能修改输入的数组。例如，如果输入长度为8的数组{2, 3, 5, 4, 3, 2, 6, 7}，那么对应的输出是重复的数字2或3。|\n|---|\n\n这题可以用题目一的简单题方法二来做。由于数组可以被看作是一类特殊的哈希表（下标作为键），我们这里还可以创建一个新数组nums2，并且遍历原数组，逐一把遍历到的数字复制到新数组对应下标的位置中，使得nums2[i]=i。其实也可以用新数组记录原数组中数字出现次数。\n\n这道题和前一道题最大的区别就是：题目一中所有可能出现的数字总共为n个和数组长度是一致的，但是这道题明确数字可能性为n种的时候，数组长度是n+1；同时，把数字范围限定从1开始，也更便于后面的算法讲解。；同时，把数字范围限定从1开始，也更便于后面的算法讲解。\n\n如前面所说，这种算法的时间复杂度为O(n)，空间复杂度也为O(n)。有没有既不需要辅助空间也不需要修改数组的算法呢？\n\n### 思路\n\n已知如果要将n个不同数字放在长度为n+1的数组里，那么至少有一个数字会重复出现一次（鸽巢原理Pigeonhole Principle）。我们可以采用二分法来找到重复数字出现的范围并逐渐缩小这个范围，具体做法是：先将1\\~n分成两个区间，1\\~m和m+1\\~n；然后遍历数组，看出现在1\\~m范围内的数字个数，如果大于m，那么我们可以认为1\\~m范围内必有重复数字，反之重复数字出现在m+1\\~n范围内。\n\n### 举例\n\n以题目中长度为8的数组{2, 3, 5, 4, 3, 2, 6, 7}为例，我们首先将所有可能出现的数字1\\~7分成两个区间，1\\~4和5\\~7，然后遍历数组发现出现在1\\~4之间的数字有5个，在数组中被标记为加粗字体如下{2, 3, 5, 4, 3, 2, 6, 7}，由于5>4，我们可以认为1\\~4之间一定存在某个重复数字；我们接着把1\\~4分成1\\~2和3\\~4，遍历发现出现在1\\~2之间的数字有2个，则重复数字一定出现在另一个区间3\\~4中；我们最后将3\\~4分成3和4就能发现3出现了2次，是重复数字。\n\n### 原文代码(C/C++)\n\nhttps://github.com/zhedahht/CodingInterviewChinese2/blob/master/03_02_DuplicationInArrayNoEdit/FindDuplicationNoEdit.cpp\n\n### 个人编写代码(C#)\n\n```\npublic int FindRepeatNumber2(int[] nums)\n{\n    if (nums != null && nums.Length > 1)\n    {\n        int left = 0;\n        int right = nums.Length - 1;\n        while(right >= left)\n        {\n            int mid = (left + right) / 2;\n            int acc = 0;\n            foreach (int num in nums)\n            {\n                if (num < 0 || num > nums.Length - 1)\n                {\n                    return -1;\n                }\n\n                if (num <= mid && num >= left)\n                {\n                    ++acc;\n                }\n            }\n\n            if (left == right)\n            {\n                if (acc > 1)\n                    return left;\n                else\n                    return -1;\n            }\n\n            if (acc > (mid - left) + 1)\n            {\n                right = mid;\n            }\n            else\n            {\n                left = mid + 1;\n            }\n        }\n    }\n\n    return -1;\n}\n```\n\n### 易错易混淆点\n1. 这里二分的是可能出现的数字，而非数组。\n","source":"_posts/coding-interview/coding-interview-3.md","raw":"---\ntitle: 剑指Offer面试题3：数组中重复的数字\ndate: 2022-02-19 16:20:20\ncategories: Coding Interview Edition 2\ntags: Array\ntoc: true\n---\n\n**数组**是占据一块连续内容并按照顺序存储数据的数据结构。创建数组需要先指定数组的容量大小，然后根据大小分配内存，因此空间效率不高，经常会有空闲的区域。由于数组中的内存是连续的，可以根据下标在O(1)时间读写任何元素，所以它的时间效率很高。\n\n<!--more-->\n\n</br>\n</br>\n</br>\n\n## 题目一：找出数组中重复的数字\n\n|在一个长度为n的数组里的所有数字都在0\\~n-1的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。例如，如果输入长度为7的数组{2, 3, 1, 0, 2, 5, 3}，那么对应的输出是重复的数字2或3。</br>LeetCode力扣链接：[https://leetcode-cn.com/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof/]|\n|---|\n||\n\n这道题有两个简单的题解：\n1. 将数组排序，然后遍历找出与前一元素相同的数组元素即可。排序需要O(nlogn)的时间复杂度，遍历一遍需要O(n)，所以总的时间复杂度为O(nlogn + n)。\n2. 利用哈希表在遍历数组过程中映射数组元素的存在情况：创建一个哈希表，然后遍历原数组，每当出现一个新数字的时候就把它加入到哈希表里。这种算法的时间复杂度为O(n)，但是由于创建了哈希表，所以还有空间复杂度为O(n)。\n        \n但是，还有没有不需要创建新的内存空间的算法呢？\n\n### 思路\n\n我们已知数字都在0\\~n-1的范围内，这意味着将数字从小到大排序后每个数组元素的下标将会和数字相等。利用这个特性，我们可以准确找出每个数字应该存在的位置，如果在排序过程中发现该位置已经被对应数字占用了，那么我们就可以知道这是重复数字了。由于不能创建新对象，我们在将数字归位的时候只能将其与取出的数字进行位置交换。如此一来，只要完整遍历一次数组就能找出重复数字了。\n\n### 举例\n\n以题目中的{2, 3, 1, 0, 2, 5, 3}为例，我们从第一个元素开始遍历。第一个元素是nums[0]=2，应该放在nums[2]=1的位置，我们交换两者的位置后使得nums[0]=1，由于nums[0]里的数字不应该为1，我们要继续帮1找位置；我们将num[1]=3和nums[0]=1进行交换，得到nums[0]=3；继续帮3找位置，将nums[0]=3和nums[3]=0找位置，得到nums[0]=0；由于0的位置正确，这时我们就可以看下一个元素，现在的数组是{0, 1, 2, 3, 2, 5, 3}；我们遍历了nums[1]、nums[2]、nums[3]发现数字都是正确的，直到nums[4]=2；我们像之前一样帮2找位置，这时我们又发现nums[2]=2，也即位置被正确数字占用，意味着出现重复数字，于是我们可以跳出遍历返回该重复数字。\n\n### 原文代码(C/C++)\n\nhttps://github.com/zhedahht/CodingInterviewChinese2/blob/master/03_01_DuplicationInArray/FindDuplication.cpp\n\n### 个人编写代码(C#)\n\n```\npublic int FindRepeatNumber(int[] nums)\n{\n    if (nums != null && nums.Length > 1)\n    {\n        for (int i = 0; i < nums.Length; ++i)\n        {\n            if (nums[i] < 0 || nums[i] > nums.Length -1)\n            {\n                return -1;\n            }\n        }\n\n        for (int i = 0; i < nums.Length; ++i)\n        {\n            while (nums[i] != i)\n            {\n                if (nums[i] == nums[nums[i]])\n                {\n                    return nums[i];\n                }\n\n                int temp = nums[i];\n                nums[i] = nums[nums[i]];\n                nums[temp] = temp;\n            }\n        }\n    }\n\n    return -1;\n}\n```\n\n## 题目二：不修改数组找出重复的数字\n\n|在一个长度为n+1的数组里的所有数字都在1\\~n的范围内，所以数组中至少有一个数字是重复的。请找出数组中任意一个重复的数字，但不能修改输入的数组。例如，如果输入长度为8的数组{2, 3, 5, 4, 3, 2, 6, 7}，那么对应的输出是重复的数字2或3。|\n|---|\n\n这题可以用题目一的简单题方法二来做。由于数组可以被看作是一类特殊的哈希表（下标作为键），我们这里还可以创建一个新数组nums2，并且遍历原数组，逐一把遍历到的数字复制到新数组对应下标的位置中，使得nums2[i]=i。其实也可以用新数组记录原数组中数字出现次数。\n\n这道题和前一道题最大的区别就是：题目一中所有可能出现的数字总共为n个和数组长度是一致的，但是这道题明确数字可能性为n种的时候，数组长度是n+1；同时，把数字范围限定从1开始，也更便于后面的算法讲解。；同时，把数字范围限定从1开始，也更便于后面的算法讲解。\n\n如前面所说，这种算法的时间复杂度为O(n)，空间复杂度也为O(n)。有没有既不需要辅助空间也不需要修改数组的算法呢？\n\n### 思路\n\n已知如果要将n个不同数字放在长度为n+1的数组里，那么至少有一个数字会重复出现一次（鸽巢原理Pigeonhole Principle）。我们可以采用二分法来找到重复数字出现的范围并逐渐缩小这个范围，具体做法是：先将1\\~n分成两个区间，1\\~m和m+1\\~n；然后遍历数组，看出现在1\\~m范围内的数字个数，如果大于m，那么我们可以认为1\\~m范围内必有重复数字，反之重复数字出现在m+1\\~n范围内。\n\n### 举例\n\n以题目中长度为8的数组{2, 3, 5, 4, 3, 2, 6, 7}为例，我们首先将所有可能出现的数字1\\~7分成两个区间，1\\~4和5\\~7，然后遍历数组发现出现在1\\~4之间的数字有5个，在数组中被标记为加粗字体如下{2, 3, 5, 4, 3, 2, 6, 7}，由于5>4，我们可以认为1\\~4之间一定存在某个重复数字；我们接着把1\\~4分成1\\~2和3\\~4，遍历发现出现在1\\~2之间的数字有2个，则重复数字一定出现在另一个区间3\\~4中；我们最后将3\\~4分成3和4就能发现3出现了2次，是重复数字。\n\n### 原文代码(C/C++)\n\nhttps://github.com/zhedahht/CodingInterviewChinese2/blob/master/03_02_DuplicationInArrayNoEdit/FindDuplicationNoEdit.cpp\n\n### 个人编写代码(C#)\n\n```\npublic int FindRepeatNumber2(int[] nums)\n{\n    if (nums != null && nums.Length > 1)\n    {\n        int left = 0;\n        int right = nums.Length - 1;\n        while(right >= left)\n        {\n            int mid = (left + right) / 2;\n            int acc = 0;\n            foreach (int num in nums)\n            {\n                if (num < 0 || num > nums.Length - 1)\n                {\n                    return -1;\n                }\n\n                if (num <= mid && num >= left)\n                {\n                    ++acc;\n                }\n            }\n\n            if (left == right)\n            {\n                if (acc > 1)\n                    return left;\n                else\n                    return -1;\n            }\n\n            if (acc > (mid - left) + 1)\n            {\n                right = mid;\n            }\n            else\n            {\n                left = mid + 1;\n            }\n        }\n    }\n\n    return -1;\n}\n```\n\n### 易错易混淆点\n1. 这里二分的是可能出现的数字，而非数组。\n","slug":"coding-interview/coding-interview-3","published":1,"updated":"2022-02-20T10:09:48.418Z","_id":"ckztkpexq000exoup5s0wgf73","comments":1,"layout":"post","photos":[],"link":"","content":"<p><strong>数组</strong>是占据一块连续内容并按照顺序存储数据的数据结构。创建数组需要先指定数组的容量大小，然后根据大小分配内存，因此空间效率不高，经常会有空闲的区域。由于数组中的内存是连续的，可以根据下标在O(1)时间读写任何元素，所以它的时间效率很高。</p>\n<span id=\"more\"></span>\n\n</br>\n</br>\n</br>\n\n<h2 id=\"题目一：找出数组中重复的数字\"><a href=\"#题目一：找出数组中重复的数字\" class=\"headerlink\" title=\"题目一：找出数组中重复的数字\"></a>题目一：找出数组中重复的数字</h2><table>\n<thead>\n<tr>\n<th>在一个长度为n的数组里的所有数字都在0~n-1的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。例如，如果输入长度为7的数组{2, 3, 1, 0, 2, 5, 3}，那么对应的输出是重复的数字2或3。</br>LeetCode力扣链接：[<a href=\"https://leetcode-cn.com/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof/]\">https://leetcode-cn.com/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof/]</a></th>\n</tr>\n</thead>\n<tbody><tr>\n<td></td>\n</tr>\n</tbody></table>\n<p>这道题有两个简单的题解：</p>\n<ol>\n<li>将数组排序，然后遍历找出与前一元素相同的数组元素即可。排序需要O(nlogn)的时间复杂度，遍历一遍需要O(n)，所以总的时间复杂度为O(nlogn + n)。</li>\n<li>利用哈希表在遍历数组过程中映射数组元素的存在情况：创建一个哈希表，然后遍历原数组，每当出现一个新数字的时候就把它加入到哈希表里。这种算法的时间复杂度为O(n)，但是由于创建了哈希表，所以还有空间复杂度为O(n)。</li>\n</ol>\n<p>但是，还有没有不需要创建新的内存空间的算法呢？</p>\n<h3 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h3><p>我们已知数字都在0~n-1的范围内，这意味着将数字从小到大排序后每个数组元素的下标将会和数字相等。利用这个特性，我们可以准确找出每个数字应该存在的位置，如果在排序过程中发现该位置已经被对应数字占用了，那么我们就可以知道这是重复数字了。由于不能创建新对象，我们在将数字归位的时候只能将其与取出的数字进行位置交换。如此一来，只要完整遍历一次数组就能找出重复数字了。</p>\n<h3 id=\"举例\"><a href=\"#举例\" class=\"headerlink\" title=\"举例\"></a>举例</h3><p>以题目中的{2, 3, 1, 0, 2, 5, 3}为例，我们从第一个元素开始遍历。第一个元素是nums[0]=2，应该放在nums[2]=1的位置，我们交换两者的位置后使得nums[0]=1，由于nums[0]里的数字不应该为1，我们要继续帮1找位置；我们将num[1]=3和nums[0]=1进行交换，得到nums[0]=3；继续帮3找位置，将nums[0]=3和nums[3]=0找位置，得到nums[0]=0；由于0的位置正确，这时我们就可以看下一个元素，现在的数组是{0, 1, 2, 3, 2, 5, 3}；我们遍历了nums[1]、nums[2]、nums[3]发现数字都是正确的，直到nums[4]=2；我们像之前一样帮2找位置，这时我们又发现nums[2]=2，也即位置被正确数字占用，意味着出现重复数字，于是我们可以跳出遍历返回该重复数字。</p>\n<h3 id=\"原文代码-C-C\"><a href=\"#原文代码-C-C\" class=\"headerlink\" title=\"原文代码(C/C++)\"></a>原文代码(C/C++)</h3><p><a href=\"https://github.com/zhedahht/CodingInterviewChinese2/blob/master/03_01_DuplicationInArray/FindDuplication.cpp\">https://github.com/zhedahht/CodingInterviewChinese2/blob/master/03_01_DuplicationInArray/FindDuplication.cpp</a></p>\n<h3 id=\"个人编写代码-C\"><a href=\"#个人编写代码-C\" class=\"headerlink\" title=\"个人编写代码(C#)\"></a>个人编写代码(C#)</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public int FindRepeatNumber(int[] nums)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    if (nums != null &amp;&amp; nums.Length &gt; 1)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        for (int i = 0; i &lt; nums.Length; ++i)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            if (nums[i] &lt; 0 || nums[i] &gt; nums.Length -1)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                return -1;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        for (int i = 0; i &lt; nums.Length; ++i)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            while (nums[i] != i)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                if (nums[i] == nums[nums[i]])</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    return nums[i];</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                int temp = nums[i];</span><br><span class=\"line\">                nums[i] = nums[nums[i]];</span><br><span class=\"line\">                nums[temp] = temp;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    return -1;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"题目二：不修改数组找出重复的数字\"><a href=\"#题目二：不修改数组找出重复的数字\" class=\"headerlink\" title=\"题目二：不修改数组找出重复的数字\"></a>题目二：不修改数组找出重复的数字</h2><table>\n<thead>\n<tr>\n<th>在一个长度为n+1的数组里的所有数字都在1~n的范围内，所以数组中至少有一个数字是重复的。请找出数组中任意一个重复的数字，但不能修改输入的数组。例如，如果输入长度为8的数组{2, 3, 5, 4, 3, 2, 6, 7}，那么对应的输出是重复的数字2或3。</th>\n</tr>\n</thead>\n</table>\n<p>这题可以用题目一的简单题方法二来做。由于数组可以被看作是一类特殊的哈希表（下标作为键），我们这里还可以创建一个新数组nums2，并且遍历原数组，逐一把遍历到的数字复制到新数组对应下标的位置中，使得nums2[i]=i。其实也可以用新数组记录原数组中数字出现次数。</p>\n<p>这道题和前一道题最大的区别就是：题目一中所有可能出现的数字总共为n个和数组长度是一致的，但是这道题明确数字可能性为n种的时候，数组长度是n+1；同时，把数字范围限定从1开始，也更便于后面的算法讲解。；同时，把数字范围限定从1开始，也更便于后面的算法讲解。</p>\n<p>如前面所说，这种算法的时间复杂度为O(n)，空间复杂度也为O(n)。有没有既不需要辅助空间也不需要修改数组的算法呢？</p>\n<h3 id=\"思路-1\"><a href=\"#思路-1\" class=\"headerlink\" title=\"思路\"></a>思路</h3><p>已知如果要将n个不同数字放在长度为n+1的数组里，那么至少有一个数字会重复出现一次（鸽巢原理Pigeonhole Principle）。我们可以采用二分法来找到重复数字出现的范围并逐渐缩小这个范围，具体做法是：先将1~n分成两个区间，1~m和m+1~n；然后遍历数组，看出现在1~m范围内的数字个数，如果大于m，那么我们可以认为1~m范围内必有重复数字，反之重复数字出现在m+1~n范围内。</p>\n<h3 id=\"举例-1\"><a href=\"#举例-1\" class=\"headerlink\" title=\"举例\"></a>举例</h3><p>以题目中长度为8的数组{2, 3, 5, 4, 3, 2, 6, 7}为例，我们首先将所有可能出现的数字1~7分成两个区间，1~4和5~7，然后遍历数组发现出现在1~4之间的数字有5个，在数组中被标记为加粗字体如下{2, 3, 5, 4, 3, 2, 6, 7}，由于5&gt;4，我们可以认为1~4之间一定存在某个重复数字；我们接着把1~4分成1~2和3~4，遍历发现出现在1~2之间的数字有2个，则重复数字一定出现在另一个区间3~4中；我们最后将3~4分成3和4就能发现3出现了2次，是重复数字。</p>\n<h3 id=\"原文代码-C-C-1\"><a href=\"#原文代码-C-C-1\" class=\"headerlink\" title=\"原文代码(C/C++)\"></a>原文代码(C/C++)</h3><p><a href=\"https://github.com/zhedahht/CodingInterviewChinese2/blob/master/03_02_DuplicationInArrayNoEdit/FindDuplicationNoEdit.cpp\">https://github.com/zhedahht/CodingInterviewChinese2/blob/master/03_02_DuplicationInArrayNoEdit/FindDuplicationNoEdit.cpp</a></p>\n<h3 id=\"个人编写代码-C-1\"><a href=\"#个人编写代码-C-1\" class=\"headerlink\" title=\"个人编写代码(C#)\"></a>个人编写代码(C#)</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public int FindRepeatNumber2(int[] nums)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    if (nums != null &amp;&amp; nums.Length &gt; 1)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        int left = 0;</span><br><span class=\"line\">        int right = nums.Length - 1;</span><br><span class=\"line\">        while(right &gt;= left)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            int mid = (left + right) / 2;</span><br><span class=\"line\">            int acc = 0;</span><br><span class=\"line\">            foreach (int num in nums)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                if (num &lt; 0 || num &gt; nums.Length - 1)</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    return -1;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                if (num &lt;= mid &amp;&amp; num &gt;= left)</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    ++acc;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            if (left == right)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                if (acc &gt; 1)</span><br><span class=\"line\">                    return left;</span><br><span class=\"line\">                else</span><br><span class=\"line\">                    return -1;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            if (acc &gt; (mid - left) + 1)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                right = mid;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            else</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                left = mid + 1;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    return -1;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"易错易混淆点\"><a href=\"#易错易混淆点\" class=\"headerlink\" title=\"易错易混淆点\"></a>易错易混淆点</h3><ol>\n<li>这里二分的是可能出现的数字，而非数组。</li>\n</ol>\n","site":{"data":{}},"excerpt":"<p><strong>数组</strong>是占据一块连续内容并按照顺序存储数据的数据结构。创建数组需要先指定数组的容量大小，然后根据大小分配内存，因此空间效率不高，经常会有空闲的区域。由于数组中的内存是连续的，可以根据下标在O(1)时间读写任何元素，所以它的时间效率很高。</p>","more":"</br>\n</br>\n</br>\n\n<h2 id=\"题目一：找出数组中重复的数字\"><a href=\"#题目一：找出数组中重复的数字\" class=\"headerlink\" title=\"题目一：找出数组中重复的数字\"></a>题目一：找出数组中重复的数字</h2><table>\n<thead>\n<tr>\n<th>在一个长度为n的数组里的所有数字都在0~n-1的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。例如，如果输入长度为7的数组{2, 3, 1, 0, 2, 5, 3}，那么对应的输出是重复的数字2或3。</br>LeetCode力扣链接：[<a href=\"https://leetcode-cn.com/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof/]\">https://leetcode-cn.com/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof/]</a></th>\n</tr>\n</thead>\n<tbody><tr>\n<td></td>\n</tr>\n</tbody></table>\n<p>这道题有两个简单的题解：</p>\n<ol>\n<li>将数组排序，然后遍历找出与前一元素相同的数组元素即可。排序需要O(nlogn)的时间复杂度，遍历一遍需要O(n)，所以总的时间复杂度为O(nlogn + n)。</li>\n<li>利用哈希表在遍历数组过程中映射数组元素的存在情况：创建一个哈希表，然后遍历原数组，每当出现一个新数字的时候就把它加入到哈希表里。这种算法的时间复杂度为O(n)，但是由于创建了哈希表，所以还有空间复杂度为O(n)。</li>\n</ol>\n<p>但是，还有没有不需要创建新的内存空间的算法呢？</p>\n<h3 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h3><p>我们已知数字都在0~n-1的范围内，这意味着将数字从小到大排序后每个数组元素的下标将会和数字相等。利用这个特性，我们可以准确找出每个数字应该存在的位置，如果在排序过程中发现该位置已经被对应数字占用了，那么我们就可以知道这是重复数字了。由于不能创建新对象，我们在将数字归位的时候只能将其与取出的数字进行位置交换。如此一来，只要完整遍历一次数组就能找出重复数字了。</p>\n<h3 id=\"举例\"><a href=\"#举例\" class=\"headerlink\" title=\"举例\"></a>举例</h3><p>以题目中的{2, 3, 1, 0, 2, 5, 3}为例，我们从第一个元素开始遍历。第一个元素是nums[0]=2，应该放在nums[2]=1的位置，我们交换两者的位置后使得nums[0]=1，由于nums[0]里的数字不应该为1，我们要继续帮1找位置；我们将num[1]=3和nums[0]=1进行交换，得到nums[0]=3；继续帮3找位置，将nums[0]=3和nums[3]=0找位置，得到nums[0]=0；由于0的位置正确，这时我们就可以看下一个元素，现在的数组是{0, 1, 2, 3, 2, 5, 3}；我们遍历了nums[1]、nums[2]、nums[3]发现数字都是正确的，直到nums[4]=2；我们像之前一样帮2找位置，这时我们又发现nums[2]=2，也即位置被正确数字占用，意味着出现重复数字，于是我们可以跳出遍历返回该重复数字。</p>\n<h3 id=\"原文代码-C-C\"><a href=\"#原文代码-C-C\" class=\"headerlink\" title=\"原文代码(C/C++)\"></a>原文代码(C/C++)</h3><p><a href=\"https://github.com/zhedahht/CodingInterviewChinese2/blob/master/03_01_DuplicationInArray/FindDuplication.cpp\">https://github.com/zhedahht/CodingInterviewChinese2/blob/master/03_01_DuplicationInArray/FindDuplication.cpp</a></p>\n<h3 id=\"个人编写代码-C\"><a href=\"#个人编写代码-C\" class=\"headerlink\" title=\"个人编写代码(C#)\"></a>个人编写代码(C#)</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public int FindRepeatNumber(int[] nums)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    if (nums != null &amp;&amp; nums.Length &gt; 1)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        for (int i = 0; i &lt; nums.Length; ++i)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            if (nums[i] &lt; 0 || nums[i] &gt; nums.Length -1)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                return -1;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        for (int i = 0; i &lt; nums.Length; ++i)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            while (nums[i] != i)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                if (nums[i] == nums[nums[i]])</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    return nums[i];</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                int temp = nums[i];</span><br><span class=\"line\">                nums[i] = nums[nums[i]];</span><br><span class=\"line\">                nums[temp] = temp;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    return -1;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"题目二：不修改数组找出重复的数字\"><a href=\"#题目二：不修改数组找出重复的数字\" class=\"headerlink\" title=\"题目二：不修改数组找出重复的数字\"></a>题目二：不修改数组找出重复的数字</h2><table>\n<thead>\n<tr>\n<th>在一个长度为n+1的数组里的所有数字都在1~n的范围内，所以数组中至少有一个数字是重复的。请找出数组中任意一个重复的数字，但不能修改输入的数组。例如，如果输入长度为8的数组{2, 3, 5, 4, 3, 2, 6, 7}，那么对应的输出是重复的数字2或3。</th>\n</tr>\n</thead>\n</table>\n<p>这题可以用题目一的简单题方法二来做。由于数组可以被看作是一类特殊的哈希表（下标作为键），我们这里还可以创建一个新数组nums2，并且遍历原数组，逐一把遍历到的数字复制到新数组对应下标的位置中，使得nums2[i]=i。其实也可以用新数组记录原数组中数字出现次数。</p>\n<p>这道题和前一道题最大的区别就是：题目一中所有可能出现的数字总共为n个和数组长度是一致的，但是这道题明确数字可能性为n种的时候，数组长度是n+1；同时，把数字范围限定从1开始，也更便于后面的算法讲解。；同时，把数字范围限定从1开始，也更便于后面的算法讲解。</p>\n<p>如前面所说，这种算法的时间复杂度为O(n)，空间复杂度也为O(n)。有没有既不需要辅助空间也不需要修改数组的算法呢？</p>\n<h3 id=\"思路-1\"><a href=\"#思路-1\" class=\"headerlink\" title=\"思路\"></a>思路</h3><p>已知如果要将n个不同数字放在长度为n+1的数组里，那么至少有一个数字会重复出现一次（鸽巢原理Pigeonhole Principle）。我们可以采用二分法来找到重复数字出现的范围并逐渐缩小这个范围，具体做法是：先将1~n分成两个区间，1~m和m+1~n；然后遍历数组，看出现在1~m范围内的数字个数，如果大于m，那么我们可以认为1~m范围内必有重复数字，反之重复数字出现在m+1~n范围内。</p>\n<h3 id=\"举例-1\"><a href=\"#举例-1\" class=\"headerlink\" title=\"举例\"></a>举例</h3><p>以题目中长度为8的数组{2, 3, 5, 4, 3, 2, 6, 7}为例，我们首先将所有可能出现的数字1~7分成两个区间，1~4和5~7，然后遍历数组发现出现在1~4之间的数字有5个，在数组中被标记为加粗字体如下{2, 3, 5, 4, 3, 2, 6, 7}，由于5&gt;4，我们可以认为1~4之间一定存在某个重复数字；我们接着把1~4分成1~2和3~4，遍历发现出现在1~2之间的数字有2个，则重复数字一定出现在另一个区间3~4中；我们最后将3~4分成3和4就能发现3出现了2次，是重复数字。</p>\n<h3 id=\"原文代码-C-C-1\"><a href=\"#原文代码-C-C-1\" class=\"headerlink\" title=\"原文代码(C/C++)\"></a>原文代码(C/C++)</h3><p><a href=\"https://github.com/zhedahht/CodingInterviewChinese2/blob/master/03_02_DuplicationInArrayNoEdit/FindDuplicationNoEdit.cpp\">https://github.com/zhedahht/CodingInterviewChinese2/blob/master/03_02_DuplicationInArrayNoEdit/FindDuplicationNoEdit.cpp</a></p>\n<h3 id=\"个人编写代码-C-1\"><a href=\"#个人编写代码-C-1\" class=\"headerlink\" title=\"个人编写代码(C#)\"></a>个人编写代码(C#)</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public int FindRepeatNumber2(int[] nums)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    if (nums != null &amp;&amp; nums.Length &gt; 1)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        int left = 0;</span><br><span class=\"line\">        int right = nums.Length - 1;</span><br><span class=\"line\">        while(right &gt;= left)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            int mid = (left + right) / 2;</span><br><span class=\"line\">            int acc = 0;</span><br><span class=\"line\">            foreach (int num in nums)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                if (num &lt; 0 || num &gt; nums.Length - 1)</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    return -1;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                if (num &lt;= mid &amp;&amp; num &gt;= left)</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    ++acc;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            if (left == right)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                if (acc &gt; 1)</span><br><span class=\"line\">                    return left;</span><br><span class=\"line\">                else</span><br><span class=\"line\">                    return -1;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            if (acc &gt; (mid - left) + 1)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                right = mid;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            else</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                left = mid + 1;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    return -1;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"易错易混淆点\"><a href=\"#易错易混淆点\" class=\"headerlink\" title=\"易错易混淆点\"></a>易错易混淆点</h3><ol>\n<li>这里二分的是可能出现的数字，而非数组。</li>\n</ol>"},{"title":"剑指Offer题解前言","date":"2022-02-18T16:00:00.000Z","_content":"\n这里主要讲解本书中的数据结构和算法相关面试题，其多作为技术面试过程中手写代码的题目。除了详述解题思路，涉及到的数据结构和知识点，还会重点描述在独立完成代码并与书中“标准答案”对比后发现的一些容易被忽视的问题。\n\n<!--more-->\n\n希望自己能够在写题解的过程中巩固知识，同时以此作为未来可以温故知新的笔记本，当然也希望能够帮助大家理解这些面试题。\n\n由于博主的工作原因，这里会使用C#作为解题语言，但同时也会附上书中的代码（如有侵权可联系删除）。本书还有许多面试技巧和经验传授，以及模式设计题的讲解，个人认为都比较通俗易懂，这里不会赘述，建议感兴趣的朋友还是自己买一本来看看。\n\n一些所有面试题都通用的技巧和Tips:\n1. 首先写好测试用例；\n2. 记住要对边界值、无效输入、异常进行处理；","source":"_posts/coding-interview/coding-interview-0.md","raw":"---\ntitle: 剑指Offer题解前言\ndate: 2022-02-19\ncategories: Coding Interview Edition 2\ntags:\n---\n\n这里主要讲解本书中的数据结构和算法相关面试题，其多作为技术面试过程中手写代码的题目。除了详述解题思路，涉及到的数据结构和知识点，还会重点描述在独立完成代码并与书中“标准答案”对比后发现的一些容易被忽视的问题。\n\n<!--more-->\n\n希望自己能够在写题解的过程中巩固知识，同时以此作为未来可以温故知新的笔记本，当然也希望能够帮助大家理解这些面试题。\n\n由于博主的工作原因，这里会使用C#作为解题语言，但同时也会附上书中的代码（如有侵权可联系删除）。本书还有许多面试技巧和经验传授，以及模式设计题的讲解，个人认为都比较通俗易懂，这里不会赘述，建议感兴趣的朋友还是自己买一本来看看。\n\n一些所有面试题都通用的技巧和Tips:\n1. 首先写好测试用例；\n2. 记住要对边界值、无效输入、异常进行处理；","slug":"coding-interview/coding-interview-0","published":1,"updated":"2022-02-20T07:59:20.578Z","_id":"ckztkpexr000fxoup0p0adiym","comments":1,"layout":"post","photos":[],"link":"","content":"<p>这里主要讲解本书中的数据结构和算法相关面试题，其多作为技术面试过程中手写代码的题目。除了详述解题思路，涉及到的数据结构和知识点，还会重点描述在独立完成代码并与书中“标准答案”对比后发现的一些容易被忽视的问题。</p>\n<span id=\"more\"></span>\n\n<p>希望自己能够在写题解的过程中巩固知识，同时以此作为未来可以温故知新的笔记本，当然也希望能够帮助大家理解这些面试题。</p>\n<p>由于博主的工作原因，这里会使用C#作为解题语言，但同时也会附上书中的代码（如有侵权可联系删除）。本书还有许多面试技巧和经验传授，以及模式设计题的讲解，个人认为都比较通俗易懂，这里不会赘述，建议感兴趣的朋友还是自己买一本来看看。</p>\n<p>一些所有面试题都通用的技巧和Tips:</p>\n<ol>\n<li>首先写好测试用例；</li>\n<li>记住要对边界值、无效输入、异常进行处理；</li>\n</ol>\n","site":{"data":{}},"excerpt":"<p>这里主要讲解本书中的数据结构和算法相关面试题，其多作为技术面试过程中手写代码的题目。除了详述解题思路，涉及到的数据结构和知识点，还会重点描述在独立完成代码并与书中“标准答案”对比后发现的一些容易被忽视的问题。</p>","more":"<p>希望自己能够在写题解的过程中巩固知识，同时以此作为未来可以温故知新的笔记本，当然也希望能够帮助大家理解这些面试题。</p>\n<p>由于博主的工作原因，这里会使用C#作为解题语言，但同时也会附上书中的代码（如有侵权可联系删除）。本书还有许多面试技巧和经验传授，以及模式设计题的讲解，个人认为都比较通俗易懂，这里不会赘述，建议感兴趣的朋友还是自己买一本来看看。</p>\n<p>一些所有面试题都通用的技巧和Tips:</p>\n<ol>\n<li>首先写好测试用例；</li>\n<li>记住要对边界值、无效输入、异常进行处理；</li>\n</ol>"},{"title":"Azure Data Explorer (Kusto)","date":"2022-02-19T08:35:58.000Z","_content":"\n> _**Azure Data Explorer** is a fully managed, high-performance, big data analytics platform that makes it easy to analyze high volumes of data in near real time._\n\n<!--more-->\n\n## How-to Guides\n\n### Purge\n\n## Kusto Query Language (KQL)\n\n### Aggregation Functions\n\n#### hll()\n\n```| summarize hll(column1) by column2```\n\nHyperLogLog is a probabilistic algorithm to estimate the number of distinct values in a set.\n\nThe basis of the HyperLogLog algorithm is the observation that the cardinality of a multiset of uniformly distributed random numbers can be estimated by calculating the maximum number of leading zeros in the binary representation of each number in the set. If the maximum number of leading zeros observed is n, an estimate for the number of distinct elements in the set is 2^n.\n\nFirst, all values should be hashed to uniformly distributed random numbers. To minimise the variance, the numbers can be splitted to numerous subsets. After then, find the maximum number of leading zeros in each subset, use a harmonic mean to combine these estimates, and obtain an estimate of the cardinality of the whole set.\n\nReference: https://en.wikipedia.org/wiki/HyperLogLog\n\n#### tdigest()\n\n```| summarize tdigest(column1) by column2```\n\nCalculates the intermediate results for percentile across the group, which are represented as a dynamic array. For example, the result ```[[5],[2,3],[1,2]]``` for a specific group means there are 5 groups in total, with one 2 and two 3s in this group.","source":"_posts/azure/azure-data-explorer.md","raw":"---\ntitle: Azure Data Explorer (Kusto)\ndate: 2022-02-19 16:35:58\ncategories: Azure\ntags:\n---\n\n> _**Azure Data Explorer** is a fully managed, high-performance, big data analytics platform that makes it easy to analyze high volumes of data in near real time._\n\n<!--more-->\n\n## How-to Guides\n\n### Purge\n\n## Kusto Query Language (KQL)\n\n### Aggregation Functions\n\n#### hll()\n\n```| summarize hll(column1) by column2```\n\nHyperLogLog is a probabilistic algorithm to estimate the number of distinct values in a set.\n\nThe basis of the HyperLogLog algorithm is the observation that the cardinality of a multiset of uniformly distributed random numbers can be estimated by calculating the maximum number of leading zeros in the binary representation of each number in the set. If the maximum number of leading zeros observed is n, an estimate for the number of distinct elements in the set is 2^n.\n\nFirst, all values should be hashed to uniformly distributed random numbers. To minimise the variance, the numbers can be splitted to numerous subsets. After then, find the maximum number of leading zeros in each subset, use a harmonic mean to combine these estimates, and obtain an estimate of the cardinality of the whole set.\n\nReference: https://en.wikipedia.org/wiki/HyperLogLog\n\n#### tdigest()\n\n```| summarize tdigest(column1) by column2```\n\nCalculates the intermediate results for percentile across the group, which are represented as a dynamic array. For example, the result ```[[5],[2,3],[1,2]]``` for a specific group means there are 5 groups in total, with one 2 and two 3s in this group.","slug":"azure/azure-data-explorer","published":1,"updated":"2022-02-20T10:13:46.869Z","_id":"ckztmbsra0000mgup3vcpfmky","comments":1,"layout":"post","photos":[],"link":"","content":"<blockquote>\n<p><em><strong>Azure Data Explorer</strong> is a fully managed, high-performance, big data analytics platform that makes it easy to analyze high volumes of data in near real time.</em></p>\n</blockquote>\n<span id=\"more\"></span>\n\n<h2 id=\"How-to-Guides\"><a href=\"#How-to-Guides\" class=\"headerlink\" title=\"How-to Guides\"></a>How-to Guides</h2><h3 id=\"Purge\"><a href=\"#Purge\" class=\"headerlink\" title=\"Purge\"></a>Purge</h3><h2 id=\"Kusto-Query-Language-KQL\"><a href=\"#Kusto-Query-Language-KQL\" class=\"headerlink\" title=\"Kusto Query Language (KQL)\"></a>Kusto Query Language (KQL)</h2><h3 id=\"Aggregation-Functions\"><a href=\"#Aggregation-Functions\" class=\"headerlink\" title=\"Aggregation Functions\"></a>Aggregation Functions</h3><h4 id=\"hll\"><a href=\"#hll\" class=\"headerlink\" title=\"hll()\"></a>hll()</h4><p><code>| summarize hll(column1) by column2</code></p>\n<p>HyperLogLog is a probabilistic algorithm to estimate the number of distinct values in a set.</p>\n<p>The basis of the HyperLogLog algorithm is the observation that the cardinality of a multiset of uniformly distributed random numbers can be estimated by calculating the maximum number of leading zeros in the binary representation of each number in the set. If the maximum number of leading zeros observed is n, an estimate for the number of distinct elements in the set is 2^n.</p>\n<p>First, all values should be hashed to uniformly distributed random numbers. To minimise the variance, the numbers can be splitted to numerous subsets. After then, find the maximum number of leading zeros in each subset, use a harmonic mean to combine these estimates, and obtain an estimate of the cardinality of the whole set.</p>\n<p>Reference: <a href=\"https://en.wikipedia.org/wiki/HyperLogLog\">https://en.wikipedia.org/wiki/HyperLogLog</a></p>\n<h4 id=\"tdigest\"><a href=\"#tdigest\" class=\"headerlink\" title=\"tdigest()\"></a>tdigest()</h4><p><code>| summarize tdigest(column1) by column2</code></p>\n<p>Calculates the intermediate results for percentile across the group, which are represented as a dynamic array. For example, the result <code>[[5],[2,3],[1,2]]</code> for a specific group means there are 5 groups in total, with one 2 and two 3s in this group.</p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p><em><strong>Azure Data Explorer</strong> is a fully managed, high-performance, big data analytics platform that makes it easy to analyze high volumes of data in near real time.</em></p>\n</blockquote>","more":"<h2 id=\"How-to-Guides\"><a href=\"#How-to-Guides\" class=\"headerlink\" title=\"How-to Guides\"></a>How-to Guides</h2><h3 id=\"Purge\"><a href=\"#Purge\" class=\"headerlink\" title=\"Purge\"></a>Purge</h3><h2 id=\"Kusto-Query-Language-KQL\"><a href=\"#Kusto-Query-Language-KQL\" class=\"headerlink\" title=\"Kusto Query Language (KQL)\"></a>Kusto Query Language (KQL)</h2><h3 id=\"Aggregation-Functions\"><a href=\"#Aggregation-Functions\" class=\"headerlink\" title=\"Aggregation Functions\"></a>Aggregation Functions</h3><h4 id=\"hll\"><a href=\"#hll\" class=\"headerlink\" title=\"hll()\"></a>hll()</h4><p><code>| summarize hll(column1) by column2</code></p>\n<p>HyperLogLog is a probabilistic algorithm to estimate the number of distinct values in a set.</p>\n<p>The basis of the HyperLogLog algorithm is the observation that the cardinality of a multiset of uniformly distributed random numbers can be estimated by calculating the maximum number of leading zeros in the binary representation of each number in the set. If the maximum number of leading zeros observed is n, an estimate for the number of distinct elements in the set is 2^n.</p>\n<p>First, all values should be hashed to uniformly distributed random numbers. To minimise the variance, the numbers can be splitted to numerous subsets. After then, find the maximum number of leading zeros in each subset, use a harmonic mean to combine these estimates, and obtain an estimate of the cardinality of the whole set.</p>\n<p>Reference: <a href=\"https://en.wikipedia.org/wiki/HyperLogLog\">https://en.wikipedia.org/wiki/HyperLogLog</a></p>\n<h4 id=\"tdigest\"><a href=\"#tdigest\" class=\"headerlink\" title=\"tdigest()\"></a>tdigest()</h4><p><code>| summarize tdigest(column1) by column2</code></p>\n<p>Calculates the intermediate results for percentile across the group, which are represented as a dynamic array. For example, the result <code>[[5],[2,3],[1,2]]</code> for a specific group means there are 5 groups in total, with one 2 and two 3s in this group.</p>"},{"title":"剑指Offer面试题4：二维数组中的查找","date":"2022-02-19T18:35:19.000Z","_content":"\n在C#语言里面，有两种表达**二维数组**的方式，一种称为交错数组（Jagged Array），另一种称为多维数组（Multi-Dimensional Array）。其中，交错数组可以理解为一维数组，其元素也为数组，各元素之间大小可能不同；多维数组具有多个维度，每一维度的各元素都具有相同大小。\n\n<!--more-->\n\n|在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序牌组。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数，如果存在则返回true，否则返回false。</br>LeetCode力扣链接：[https://leetcode-cn.com/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof/]|\n|---|\n\n如下面的二维数组，每行每列都是递增排序。\n1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;9\n2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;9&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;12\n4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;7&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;10&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;13\n6&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;11&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;15\n\n<!-- |     |     |     |     |     |     |     |     |\n|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|\n|  1  |  2  |   8 |   9 |     |     |     |     |\n|  2  |  4  |   9 |  12 |     |     |     |     |\n|  4  |  7  |  10 |  13 |     |     |     |     |\n|  6  |  8  |  11 |  15 |     |     |     |     | -->\n\n解题的关键是这里的递增排序。假设目标数字和二维数组中的被中的数字不相同时，如果前者较大，那么它有可能出现在这一元素的右边或者下面，否则将可能出现在左边或上面。如果我们随机挑选二维数组中的数字进行比较，那么就使得可能出现目标数字的待搜索区域重叠，增加了搜索的复杂程度。\n\n那么有没有这么一个二维数组中的位置，使得其元素与目标数字进行比较时，不管前后者哪个比较大，待搜索区域只有一块？\n\n### 思路\n我们发现，二维数组左下角的位置没有左边和下面，而右上角的位置没有右边和上面，正好满足我们的需求。拿右上角举例，当目标数字较大时，它只可能出现在下面，较小时只可能出现在左边。这就意味着每次比较都会筛掉一行或者一列。循环比较直到要超越边界，就能确定数组中是否存在目标数字。\n\n### 举例\n以题目中的二维数组为例子，从左往右为第一到第四列，从上到下为第一到第四行。假设我们要找的目标数字为5（不存在），从右上角的9开始比较起，发现5比9小，那么5绝对不会出现在9所在的那一列（第四列）；我们继续跟9左边的8进行比较，发现5还是比8小，排除第三列；和8左边的2比较，发现5比较大，那么2所在的第一行也可以被排除了；和2下面的4比较，发现5更大，排除第二行；再和4下面的7比较，发现5较小，排除第二列；和7左边的4比较，发现5更大，排除第三行；和4下面的6比较，发现5更小；由于6的左边已经没有元素了，这时候我们可以跳出循环认为该二维数组中不存在数字5。\n\n### 原文代码(C/C++)\nhttps://github.com/zhedahht/CodingInterviewChinese2/blob/master/04_FindInPartiallySortedMatrix/FindInPartiallySortedMatrix.cpp\n\n### 个人编写代码(C#)\n这里的代码输入与原文有所不同，主要是为了和力扣题目保持一致，所以输入为二维数组和目标数字。\n```\npublic bool FindNumberIn2DArray(int[][] matrix, int target)\n{\n    if (matrix == null || matrix.Length == 0 || matrix[0].Length == 0)\n        return false;\n    int row = 0;\n    int col = matrix[0].Length - 1;\n    while(row < matrix.Length && col >= 0)\n    {\n        if (target > matrix[row][col])\n            ++row;\n        else if (target < matrix[row][col])\n            --col;\n        else\n            return true;\n    }\n    return false;\n}\n```\n","source":"_posts/coding-interview/coding-interview-4.md","raw":"---\ntitle: 剑指Offer面试题4：二维数组中的查找\ndate: 2022-02-20 02:35:19\ncategories: Coding Interview Edition 2\ntags: Array\n---\n\n在C#语言里面，有两种表达**二维数组**的方式，一种称为交错数组（Jagged Array），另一种称为多维数组（Multi-Dimensional Array）。其中，交错数组可以理解为一维数组，其元素也为数组，各元素之间大小可能不同；多维数组具有多个维度，每一维度的各元素都具有相同大小。\n\n<!--more-->\n\n|在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序牌组。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数，如果存在则返回true，否则返回false。</br>LeetCode力扣链接：[https://leetcode-cn.com/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof/]|\n|---|\n\n如下面的二维数组，每行每列都是递增排序。\n1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;9\n2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;9&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;12\n4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;7&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;10&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;13\n6&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;11&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;15\n\n<!-- |     |     |     |     |     |     |     |     |\n|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|\n|  1  |  2  |   8 |   9 |     |     |     |     |\n|  2  |  4  |   9 |  12 |     |     |     |     |\n|  4  |  7  |  10 |  13 |     |     |     |     |\n|  6  |  8  |  11 |  15 |     |     |     |     | -->\n\n解题的关键是这里的递增排序。假设目标数字和二维数组中的被中的数字不相同时，如果前者较大，那么它有可能出现在这一元素的右边或者下面，否则将可能出现在左边或上面。如果我们随机挑选二维数组中的数字进行比较，那么就使得可能出现目标数字的待搜索区域重叠，增加了搜索的复杂程度。\n\n那么有没有这么一个二维数组中的位置，使得其元素与目标数字进行比较时，不管前后者哪个比较大，待搜索区域只有一块？\n\n### 思路\n我们发现，二维数组左下角的位置没有左边和下面，而右上角的位置没有右边和上面，正好满足我们的需求。拿右上角举例，当目标数字较大时，它只可能出现在下面，较小时只可能出现在左边。这就意味着每次比较都会筛掉一行或者一列。循环比较直到要超越边界，就能确定数组中是否存在目标数字。\n\n### 举例\n以题目中的二维数组为例子，从左往右为第一到第四列，从上到下为第一到第四行。假设我们要找的目标数字为5（不存在），从右上角的9开始比较起，发现5比9小，那么5绝对不会出现在9所在的那一列（第四列）；我们继续跟9左边的8进行比较，发现5还是比8小，排除第三列；和8左边的2比较，发现5比较大，那么2所在的第一行也可以被排除了；和2下面的4比较，发现5更大，排除第二行；再和4下面的7比较，发现5较小，排除第二列；和7左边的4比较，发现5更大，排除第三行；和4下面的6比较，发现5更小；由于6的左边已经没有元素了，这时候我们可以跳出循环认为该二维数组中不存在数字5。\n\n### 原文代码(C/C++)\nhttps://github.com/zhedahht/CodingInterviewChinese2/blob/master/04_FindInPartiallySortedMatrix/FindInPartiallySortedMatrix.cpp\n\n### 个人编写代码(C#)\n这里的代码输入与原文有所不同，主要是为了和力扣题目保持一致，所以输入为二维数组和目标数字。\n```\npublic bool FindNumberIn2DArray(int[][] matrix, int target)\n{\n    if (matrix == null || matrix.Length == 0 || matrix[0].Length == 0)\n        return false;\n    int row = 0;\n    int col = matrix[0].Length - 1;\n    while(row < matrix.Length && col >= 0)\n    {\n        if (target > matrix[row][col])\n            ++row;\n        else if (target < matrix[row][col])\n            --col;\n        else\n            return true;\n    }\n    return false;\n}\n```\n","slug":"coding-interview/coding-interview-4","published":1,"updated":"2022-02-20T10:09:55.883Z","_id":"ckzu6odil0000xoupco5be8l6","comments":1,"layout":"post","photos":[],"link":"","content":"<p>在C#语言里面，有两种表达<strong>二维数组</strong>的方式，一种称为交错数组（Jagged Array），另一种称为多维数组（Multi-Dimensional Array）。其中，交错数组可以理解为一维数组，其元素也为数组，各元素之间大小可能不同；多维数组具有多个维度，每一维度的各元素都具有相同大小。</p>\n<span id=\"more\"></span>\n\n<table>\n<thead>\n<tr>\n<th>在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序牌组。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数，如果存在则返回true，否则返回false。</br>LeetCode力扣链接：[<a href=\"https://leetcode-cn.com/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof/]\">https://leetcode-cn.com/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof/]</a></th>\n</tr>\n</thead>\n</table>\n<p>如下面的二维数组，每行每列都是递增排序。<br>1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;9<br>2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;9&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;12<br>4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;7&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;10&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;13<br>6&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;11&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;15</p>\n<!-- |     |     |     |     |     |     |     |     |\n|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|\n|  1  |  2  |   8 |   9 |     |     |     |     |\n|  2  |  4  |   9 |  12 |     |     |     |     |\n|  4  |  7  |  10 |  13 |     |     |     |     |\n|  6  |  8  |  11 |  15 |     |     |     |     | -->\n\n<p>解题的关键是这里的递增排序。假设目标数字和二维数组中的被中的数字不相同时，如果前者较大，那么它有可能出现在这一元素的右边或者下面，否则将可能出现在左边或上面。如果我们随机挑选二维数组中的数字进行比较，那么就使得可能出现目标数字的待搜索区域重叠，增加了搜索的复杂程度。</p>\n<p>那么有没有这么一个二维数组中的位置，使得其元素与目标数字进行比较时，不管前后者哪个比较大，待搜索区域只有一块？</p>\n<h3 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h3><p>我们发现，二维数组左下角的位置没有左边和下面，而右上角的位置没有右边和上面，正好满足我们的需求。拿右上角举例，当目标数字较大时，它只可能出现在下面，较小时只可能出现在左边。这就意味着每次比较都会筛掉一行或者一列。循环比较直到要超越边界，就能确定数组中是否存在目标数字。</p>\n<h3 id=\"举例\"><a href=\"#举例\" class=\"headerlink\" title=\"举例\"></a>举例</h3><p>以题目中的二维数组为例子，从左往右为第一到第四列，从上到下为第一到第四行。假设我们要找的目标数字为5（不存在），从右上角的9开始比较起，发现5比9小，那么5绝对不会出现在9所在的那一列（第四列）；我们继续跟9左边的8进行比较，发现5还是比8小，排除第三列；和8左边的2比较，发现5比较大，那么2所在的第一行也可以被排除了；和2下面的4比较，发现5更大，排除第二行；再和4下面的7比较，发现5较小，排除第二列；和7左边的4比较，发现5更大，排除第三行；和4下面的6比较，发现5更小；由于6的左边已经没有元素了，这时候我们可以跳出循环认为该二维数组中不存在数字5。</p>\n<h3 id=\"原文代码-C-C\"><a href=\"#原文代码-C-C\" class=\"headerlink\" title=\"原文代码(C/C++)\"></a>原文代码(C/C++)</h3><p><a href=\"https://github.com/zhedahht/CodingInterviewChinese2/blob/master/04_FindInPartiallySortedMatrix/FindInPartiallySortedMatrix.cpp\">https://github.com/zhedahht/CodingInterviewChinese2/blob/master/04_FindInPartiallySortedMatrix/FindInPartiallySortedMatrix.cpp</a></p>\n<h3 id=\"个人编写代码-C\"><a href=\"#个人编写代码-C\" class=\"headerlink\" title=\"个人编写代码(C#)\"></a>个人编写代码(C#)</h3><p>这里的代码输入与原文有所不同，主要是为了和力扣题目保持一致，所以输入为二维数组和目标数字。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public bool FindNumberIn2DArray(int[][] matrix, int target)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    if (matrix == null || matrix.Length == 0 || matrix[0].Length == 0)</span><br><span class=\"line\">        return false;</span><br><span class=\"line\">    int row = 0;</span><br><span class=\"line\">    int col = matrix[0].Length - 1;</span><br><span class=\"line\">    while(row &lt; matrix.Length &amp;&amp; col &gt;= 0)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        if (target &gt; matrix[row][col])</span><br><span class=\"line\">            ++row;</span><br><span class=\"line\">        else if (target &lt; matrix[row][col])</span><br><span class=\"line\">            --col;</span><br><span class=\"line\">        else</span><br><span class=\"line\">            return true;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return false;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<p>在C#语言里面，有两种表达<strong>二维数组</strong>的方式，一种称为交错数组（Jagged Array），另一种称为多维数组（Multi-Dimensional Array）。其中，交错数组可以理解为一维数组，其元素也为数组，各元素之间大小可能不同；多维数组具有多个维度，每一维度的各元素都具有相同大小。</p>","more":"<table>\n<thead>\n<tr>\n<th>在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序牌组。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数，如果存在则返回true，否则返回false。</br>LeetCode力扣链接：[<a href=\"https://leetcode-cn.com/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof/]\">https://leetcode-cn.com/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof/]</a></th>\n</tr>\n</thead>\n</table>\n<p>如下面的二维数组，每行每列都是递增排序。<br>1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;9<br>2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;9&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;12<br>4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;7&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;10&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;13<br>6&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;11&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;15</p>\n<!-- |     |     |     |     |     |     |     |     |\n|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|\n|  1  |  2  |   8 |   9 |     |     |     |     |\n|  2  |  4  |   9 |  12 |     |     |     |     |\n|  4  |  7  |  10 |  13 |     |     |     |     |\n|  6  |  8  |  11 |  15 |     |     |     |     | -->\n\n<p>解题的关键是这里的递增排序。假设目标数字和二维数组中的被中的数字不相同时，如果前者较大，那么它有可能出现在这一元素的右边或者下面，否则将可能出现在左边或上面。如果我们随机挑选二维数组中的数字进行比较，那么就使得可能出现目标数字的待搜索区域重叠，增加了搜索的复杂程度。</p>\n<p>那么有没有这么一个二维数组中的位置，使得其元素与目标数字进行比较时，不管前后者哪个比较大，待搜索区域只有一块？</p>\n<h3 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h3><p>我们发现，二维数组左下角的位置没有左边和下面，而右上角的位置没有右边和上面，正好满足我们的需求。拿右上角举例，当目标数字较大时，它只可能出现在下面，较小时只可能出现在左边。这就意味着每次比较都会筛掉一行或者一列。循环比较直到要超越边界，就能确定数组中是否存在目标数字。</p>\n<h3 id=\"举例\"><a href=\"#举例\" class=\"headerlink\" title=\"举例\"></a>举例</h3><p>以题目中的二维数组为例子，从左往右为第一到第四列，从上到下为第一到第四行。假设我们要找的目标数字为5（不存在），从右上角的9开始比较起，发现5比9小，那么5绝对不会出现在9所在的那一列（第四列）；我们继续跟9左边的8进行比较，发现5还是比8小，排除第三列；和8左边的2比较，发现5比较大，那么2所在的第一行也可以被排除了；和2下面的4比较，发现5更大，排除第二行；再和4下面的7比较，发现5较小，排除第二列；和7左边的4比较，发现5更大，排除第三行；和4下面的6比较，发现5更小；由于6的左边已经没有元素了，这时候我们可以跳出循环认为该二维数组中不存在数字5。</p>\n<h3 id=\"原文代码-C-C\"><a href=\"#原文代码-C-C\" class=\"headerlink\" title=\"原文代码(C/C++)\"></a>原文代码(C/C++)</h3><p><a href=\"https://github.com/zhedahht/CodingInterviewChinese2/blob/master/04_FindInPartiallySortedMatrix/FindInPartiallySortedMatrix.cpp\">https://github.com/zhedahht/CodingInterviewChinese2/blob/master/04_FindInPartiallySortedMatrix/FindInPartiallySortedMatrix.cpp</a></p>\n<h3 id=\"个人编写代码-C\"><a href=\"#个人编写代码-C\" class=\"headerlink\" title=\"个人编写代码(C#)\"></a>个人编写代码(C#)</h3><p>这里的代码输入与原文有所不同，主要是为了和力扣题目保持一致，所以输入为二维数组和目标数字。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public bool FindNumberIn2DArray(int[][] matrix, int target)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    if (matrix == null || matrix.Length == 0 || matrix[0].Length == 0)</span><br><span class=\"line\">        return false;</span><br><span class=\"line\">    int row = 0;</span><br><span class=\"line\">    int col = matrix[0].Length - 1;</span><br><span class=\"line\">    while(row &lt; matrix.Length &amp;&amp; col &gt;= 0)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        if (target &gt; matrix[row][col])</span><br><span class=\"line\">            ++row;</span><br><span class=\"line\">        else if (target &lt; matrix[row][col])</span><br><span class=\"line\">            --col;</span><br><span class=\"line\">        else</span><br><span class=\"line\">            return true;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return false;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"剑指Offer面试题5：替换空格","date":"2022-02-20T07:07:00.000Z","_content":"\n**字符串**是由若干字符组成的序列。在C#中，封装字符串的的类型System.String有一个非常特殊的性质：String的内容是不能改变的。一旦试图改变String的内容，就会产生一个新的实例。如果需要多次修改String的值，那么每次修改都会产生一个临时对象，这样开销太大影响效率，所以我们通常用StringBuilder来进行多次修改字符串的操作。\n\n<!--more-->\n\n|请实现一个函数，把字符串中的每个空格替换成\"%20\"。例如，输入\"We are happy.\"，则输出\"We%20are%20happy.\"。</br> LeetCode力扣链接：[https://leetcode-cn.com/problems/ti-huan-kong-ge-lcof/]|\n|---|\n\n将空格替换成'%20'，就意味着用三个字符替换一个字符，替换完以后字符串会变长。如果输入数组的长度足够长，可以容纳替换空格后的字符串，那么替换可以在原数组中进行，否则需要创建一个新数组。\n\n可以想象，新加入的字符会占用原来空格后面字符的位置，这样就需要我们将空格后面的字符都往后移两位。如果从左往右（从前往后）遍历空格，每遇到一个空格都如前面所说的来处理，当字符串中存在多个空格，那么有一部分字符就需要移动多次。\n\n如果我们从右往左（从后往前）呢？\n\n### 思路\n先遍历一遍数组找到空格的数量，并计算出新字符串所需数组长度，这等于原字符串长度加上二倍空格数。我们在这里讨论原数组足够长的情况，以便和原文代码保持一致。这里我们先创建两个指针，p1指向旧字符串最后一位，p2指向新字符串最后一位。然后p1从后往前遍历旧字符串，遇到非空格字符则拷贝到p2指向的位置；遇到空格字符，则在p2指向的位置连续赋值'0'，'2'和'%';遍历直到p1和p2两个指针相遇为止。\n\n### 举例\n以\"We are happy.\"为例，这个字符串算上'\\0'的长度为14，其中包含2个空格，则新字符串的长度应该为14+2*2=18。\n\n![](/2022/02/20/coding-interview/coding-interview-5/replace-space.jpg)\n\n(a) 如图所示，开始时p1指向str[13]，p2指向str[17]；\n\n(b) 从后往前遍历，一直到第一个空格之前都是将p1指向的元素赋值给p2指向的位置；遇到第一个空格时p1指向str[6]，p2指向str[10]；\n\n(c) 遇到空格后，p2往前遍历的同时放入'0'，'2'和'%'三个字符，最后p1和p2都往前移动一位。此时p1指向str[5],p2指向str[7];\n\n(d) 如同(b)一样，将遇到空格前的字符都往后移动两位，随后p1指向第二个空格str[2]，p2指向[4]；\n\n(e) 往p2的位置放入'0'，'2'和'%'，两个指针往前移动一位，同时指向p[1]。p1和p2位置相同，证明前面已经没有空格，不需要继续移动字符，结束遍历。\n\n### 原文代码(C/C++)\nhttps://github.com/zhedahht/CodingInterviewChinese2/blob/master/05_ReplaceSpaces/ReplaceSpaces.cpp\n\n### 个人编写代码(C#)\n```\npublic string ReplaceSpace(string s)\n{\n    if (s == null || s.Length == 0)\n        return s;\n\n    int len = s.Length;\n    char[] str1 = s.ToCharArray();\n    foreach(char c in str1)\n    {\n        if (c.Equals(' '))\n            len += 2;\n    }\n    \n    char[] str2 = new char[len];\n\n    int p1 = str1.Length - 1;\n    int p2 = len - 1;\n    while(p1 >= 0)\n    {\n        if (str1[p1].Equals(' '))\n        {\n            str2[p2--] = '0';\n            str2[p2--] = '2';\n            str2[p2--] = '%';\n        }\n        else\n        {\n            str2[p2--] = str1[p1];\n        }\n\n        --p1;\n    }\n\n    return new string(str2);\n}\n```\n","source":"_posts/coding-interview/coding-interview-5.md","raw":"---\ntitle: 剑指Offer面试题5：替换空格\ndate: 2022-02-20 15:07:00\ncategories: Coding Interview Edition 2\ntags:\n---\n\n**字符串**是由若干字符组成的序列。在C#中，封装字符串的的类型System.String有一个非常特殊的性质：String的内容是不能改变的。一旦试图改变String的内容，就会产生一个新的实例。如果需要多次修改String的值，那么每次修改都会产生一个临时对象，这样开销太大影响效率，所以我们通常用StringBuilder来进行多次修改字符串的操作。\n\n<!--more-->\n\n|请实现一个函数，把字符串中的每个空格替换成\"%20\"。例如，输入\"We are happy.\"，则输出\"We%20are%20happy.\"。</br> LeetCode力扣链接：[https://leetcode-cn.com/problems/ti-huan-kong-ge-lcof/]|\n|---|\n\n将空格替换成'%20'，就意味着用三个字符替换一个字符，替换完以后字符串会变长。如果输入数组的长度足够长，可以容纳替换空格后的字符串，那么替换可以在原数组中进行，否则需要创建一个新数组。\n\n可以想象，新加入的字符会占用原来空格后面字符的位置，这样就需要我们将空格后面的字符都往后移两位。如果从左往右（从前往后）遍历空格，每遇到一个空格都如前面所说的来处理，当字符串中存在多个空格，那么有一部分字符就需要移动多次。\n\n如果我们从右往左（从后往前）呢？\n\n### 思路\n先遍历一遍数组找到空格的数量，并计算出新字符串所需数组长度，这等于原字符串长度加上二倍空格数。我们在这里讨论原数组足够长的情况，以便和原文代码保持一致。这里我们先创建两个指针，p1指向旧字符串最后一位，p2指向新字符串最后一位。然后p1从后往前遍历旧字符串，遇到非空格字符则拷贝到p2指向的位置；遇到空格字符，则在p2指向的位置连续赋值'0'，'2'和'%';遍历直到p1和p2两个指针相遇为止。\n\n### 举例\n以\"We are happy.\"为例，这个字符串算上'\\0'的长度为14，其中包含2个空格，则新字符串的长度应该为14+2*2=18。\n\n![](/2022/02/20/coding-interview/coding-interview-5/replace-space.jpg)\n\n(a) 如图所示，开始时p1指向str[13]，p2指向str[17]；\n\n(b) 从后往前遍历，一直到第一个空格之前都是将p1指向的元素赋值给p2指向的位置；遇到第一个空格时p1指向str[6]，p2指向str[10]；\n\n(c) 遇到空格后，p2往前遍历的同时放入'0'，'2'和'%'三个字符，最后p1和p2都往前移动一位。此时p1指向str[5],p2指向str[7];\n\n(d) 如同(b)一样，将遇到空格前的字符都往后移动两位，随后p1指向第二个空格str[2]，p2指向[4]；\n\n(e) 往p2的位置放入'0'，'2'和'%'，两个指针往前移动一位，同时指向p[1]。p1和p2位置相同，证明前面已经没有空格，不需要继续移动字符，结束遍历。\n\n### 原文代码(C/C++)\nhttps://github.com/zhedahht/CodingInterviewChinese2/blob/master/05_ReplaceSpaces/ReplaceSpaces.cpp\n\n### 个人编写代码(C#)\n```\npublic string ReplaceSpace(string s)\n{\n    if (s == null || s.Length == 0)\n        return s;\n\n    int len = s.Length;\n    char[] str1 = s.ToCharArray();\n    foreach(char c in str1)\n    {\n        if (c.Equals(' '))\n            len += 2;\n    }\n    \n    char[] str2 = new char[len];\n\n    int p1 = str1.Length - 1;\n    int p2 = len - 1;\n    while(p1 >= 0)\n    {\n        if (str1[p1].Equals(' '))\n        {\n            str2[p2--] = '0';\n            str2[p2--] = '2';\n            str2[p2--] = '%';\n        }\n        else\n        {\n            str2[p2--] = str1[p1];\n        }\n\n        --p1;\n    }\n\n    return new string(str2);\n}\n```\n","slug":"coding-interview/coding-interview-5","published":1,"updated":"2022-02-20T13:24:47.313Z","_id":"ckzuxevjb0000sgup5hfd2bnf","comments":1,"layout":"post","photos":[],"link":"","content":"<p><strong>字符串</strong>是由若干字符组成的序列。在C#中，封装字符串的的类型System.String有一个非常特殊的性质：String的内容是不能改变的。一旦试图改变String的内容，就会产生一个新的实例。如果需要多次修改String的值，那么每次修改都会产生一个临时对象，这样开销太大影响效率，所以我们通常用StringBuilder来进行多次修改字符串的操作。</p>\n<span id=\"more\"></span>\n\n<table>\n<thead>\n<tr>\n<th>请实现一个函数，把字符串中的每个空格替换成”%20”。例如，输入”We are happy.”，则输出”We%20are%20happy.”。</br> LeetCode力扣链接：[<a href=\"https://leetcode-cn.com/problems/ti-huan-kong-ge-lcof/]\">https://leetcode-cn.com/problems/ti-huan-kong-ge-lcof/]</a></th>\n</tr>\n</thead>\n</table>\n<p>将空格替换成’%20’，就意味着用三个字符替换一个字符，替换完以后字符串会变长。如果输入数组的长度足够长，可以容纳替换空格后的字符串，那么替换可以在原数组中进行，否则需要创建一个新数组。</p>\n<p>可以想象，新加入的字符会占用原来空格后面字符的位置，这样就需要我们将空格后面的字符都往后移两位。如果从左往右（从前往后）遍历空格，每遇到一个空格都如前面所说的来处理，当字符串中存在多个空格，那么有一部分字符就需要移动多次。</p>\n<p>如果我们从右往左（从后往前）呢？</p>\n<h3 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h3><p>先遍历一遍数组找到空格的数量，并计算出新字符串所需数组长度，这等于原字符串长度加上二倍空格数。我们在这里讨论原数组足够长的情况，以便和原文代码保持一致。这里我们先创建两个指针，p1指向旧字符串最后一位，p2指向新字符串最后一位。然后p1从后往前遍历旧字符串，遇到非空格字符则拷贝到p2指向的位置；遇到空格字符，则在p2指向的位置连续赋值’0’，’2’和’%’;遍历直到p1和p2两个指针相遇为止。</p>\n<h3 id=\"举例\"><a href=\"#举例\" class=\"headerlink\" title=\"举例\"></a>举例</h3><p>以”We are happy.”为例，这个字符串算上’\\0’的长度为14，其中包含2个空格，则新字符串的长度应该为14+2*2=18。</p>\n<p><img src=\"/2022/02/20/coding-interview/coding-interview-5/replace-space.jpg\"></p>\n<p>(a) 如图所示，开始时p1指向str[13]，p2指向str[17]；</p>\n<p>(b) 从后往前遍历，一直到第一个空格之前都是将p1指向的元素赋值给p2指向的位置；遇到第一个空格时p1指向str[6]，p2指向str[10]；</p>\n<p>(c) 遇到空格后，p2往前遍历的同时放入’0’，’2’和’%’三个字符，最后p1和p2都往前移动一位。此时p1指向str[5],p2指向str[7];</p>\n<p>(d) 如同(b)一样，将遇到空格前的字符都往后移动两位，随后p1指向第二个空格str[2]，p2指向[4]；</p>\n<p>(e) 往p2的位置放入’0’，’2’和’%’，两个指针往前移动一位，同时指向p[1]。p1和p2位置相同，证明前面已经没有空格，不需要继续移动字符，结束遍历。</p>\n<h3 id=\"原文代码-C-C\"><a href=\"#原文代码-C-C\" class=\"headerlink\" title=\"原文代码(C/C++)\"></a>原文代码(C/C++)</h3><p><a href=\"https://github.com/zhedahht/CodingInterviewChinese2/blob/master/05_ReplaceSpaces/ReplaceSpaces.cpp\">https://github.com/zhedahht/CodingInterviewChinese2/blob/master/05_ReplaceSpaces/ReplaceSpaces.cpp</a></p>\n<h3 id=\"个人编写代码-C\"><a href=\"#个人编写代码-C\" class=\"headerlink\" title=\"个人编写代码(C#)\"></a>个人编写代码(C#)</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public string ReplaceSpace(string s)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    if (s == null || s.Length == 0)</span><br><span class=\"line\">        return s;</span><br><span class=\"line\"></span><br><span class=\"line\">    int len = s.Length;</span><br><span class=\"line\">    char[] str1 = s.ToCharArray();</span><br><span class=\"line\">    foreach(char c in str1)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        if (c.Equals(&#x27; &#x27;))</span><br><span class=\"line\">            len += 2;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    char[] str2 = new char[len];</span><br><span class=\"line\"></span><br><span class=\"line\">    int p1 = str1.Length - 1;</span><br><span class=\"line\">    int p2 = len - 1;</span><br><span class=\"line\">    while(p1 &gt;= 0)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        if (str1[p1].Equals(&#x27; &#x27;))</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            str2[p2--] = &#x27;0&#x27;;</span><br><span class=\"line\">            str2[p2--] = &#x27;2&#x27;;</span><br><span class=\"line\">            str2[p2--] = &#x27;%&#x27;;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        else</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            str2[p2--] = str1[p1];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        --p1;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    return new string(str2);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<p><strong>字符串</strong>是由若干字符组成的序列。在C#中，封装字符串的的类型System.String有一个非常特殊的性质：String的内容是不能改变的。一旦试图改变String的内容，就会产生一个新的实例。如果需要多次修改String的值，那么每次修改都会产生一个临时对象，这样开销太大影响效率，所以我们通常用StringBuilder来进行多次修改字符串的操作。</p>","more":"<table>\n<thead>\n<tr>\n<th>请实现一个函数，把字符串中的每个空格替换成”%20”。例如，输入”We are happy.”，则输出”We%20are%20happy.”。</br> LeetCode力扣链接：[<a href=\"https://leetcode-cn.com/problems/ti-huan-kong-ge-lcof/]\">https://leetcode-cn.com/problems/ti-huan-kong-ge-lcof/]</a></th>\n</tr>\n</thead>\n</table>\n<p>将空格替换成’%20’，就意味着用三个字符替换一个字符，替换完以后字符串会变长。如果输入数组的长度足够长，可以容纳替换空格后的字符串，那么替换可以在原数组中进行，否则需要创建一个新数组。</p>\n<p>可以想象，新加入的字符会占用原来空格后面字符的位置，这样就需要我们将空格后面的字符都往后移两位。如果从左往右（从前往后）遍历空格，每遇到一个空格都如前面所说的来处理，当字符串中存在多个空格，那么有一部分字符就需要移动多次。</p>\n<p>如果我们从右往左（从后往前）呢？</p>\n<h3 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h3><p>先遍历一遍数组找到空格的数量，并计算出新字符串所需数组长度，这等于原字符串长度加上二倍空格数。我们在这里讨论原数组足够长的情况，以便和原文代码保持一致。这里我们先创建两个指针，p1指向旧字符串最后一位，p2指向新字符串最后一位。然后p1从后往前遍历旧字符串，遇到非空格字符则拷贝到p2指向的位置；遇到空格字符，则在p2指向的位置连续赋值’0’，’2’和’%’;遍历直到p1和p2两个指针相遇为止。</p>\n<h3 id=\"举例\"><a href=\"#举例\" class=\"headerlink\" title=\"举例\"></a>举例</h3><p>以”We are happy.”为例，这个字符串算上’\\0’的长度为14，其中包含2个空格，则新字符串的长度应该为14+2*2=18。</p>\n<p><img src=\"/2022/02/20/coding-interview/coding-interview-5/replace-space.jpg\"></p>\n<p>(a) 如图所示，开始时p1指向str[13]，p2指向str[17]；</p>\n<p>(b) 从后往前遍历，一直到第一个空格之前都是将p1指向的元素赋值给p2指向的位置；遇到第一个空格时p1指向str[6]，p2指向str[10]；</p>\n<p>(c) 遇到空格后，p2往前遍历的同时放入’0’，’2’和’%’三个字符，最后p1和p2都往前移动一位。此时p1指向str[5],p2指向str[7];</p>\n<p>(d) 如同(b)一样，将遇到空格前的字符都往后移动两位，随后p1指向第二个空格str[2]，p2指向[4]；</p>\n<p>(e) 往p2的位置放入’0’，’2’和’%’，两个指针往前移动一位，同时指向p[1]。p1和p2位置相同，证明前面已经没有空格，不需要继续移动字符，结束遍历。</p>\n<h3 id=\"原文代码-C-C\"><a href=\"#原文代码-C-C\" class=\"headerlink\" title=\"原文代码(C/C++)\"></a>原文代码(C/C++)</h3><p><a href=\"https://github.com/zhedahht/CodingInterviewChinese2/blob/master/05_ReplaceSpaces/ReplaceSpaces.cpp\">https://github.com/zhedahht/CodingInterviewChinese2/blob/master/05_ReplaceSpaces/ReplaceSpaces.cpp</a></p>\n<h3 id=\"个人编写代码-C\"><a href=\"#个人编写代码-C\" class=\"headerlink\" title=\"个人编写代码(C#)\"></a>个人编写代码(C#)</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public string ReplaceSpace(string s)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    if (s == null || s.Length == 0)</span><br><span class=\"line\">        return s;</span><br><span class=\"line\"></span><br><span class=\"line\">    int len = s.Length;</span><br><span class=\"line\">    char[] str1 = s.ToCharArray();</span><br><span class=\"line\">    foreach(char c in str1)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        if (c.Equals(&#x27; &#x27;))</span><br><span class=\"line\">            len += 2;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    char[] str2 = new char[len];</span><br><span class=\"line\"></span><br><span class=\"line\">    int p1 = str1.Length - 1;</span><br><span class=\"line\">    int p2 = len - 1;</span><br><span class=\"line\">    while(p1 &gt;= 0)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        if (str1[p1].Equals(&#x27; &#x27;))</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            str2[p2--] = &#x27;0&#x27;;</span><br><span class=\"line\">            str2[p2--] = &#x27;2&#x27;;</span><br><span class=\"line\">            str2[p2--] = &#x27;%&#x27;;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        else</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            str2[p2--] = str1[p1];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        --p1;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    return new string(str2);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"剑指Offer面试题6：从尾到头打印链表","date":"2022-02-20T13:28:00.000Z","_content":"\n**链表**是由指针把若干个节点连接而成的链状结构，它是一种动态数据结构，在创建之时无须知道长度。当插入一个节点的时候，只需要为新节点分配内存然后调整指针的指向来确保新节点被链接到了链表中。可以理解为“按需分配”，空间利用率较高。\n\n<!--more-->\n\n|输入一个链表的头节点，从尾到头反过来打印出每个节点的值。</br>LeetCode力扣链接：[https://leetcode-cn.com/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof/]|\n|---|\n\n由于这里涉及的链表是单向的，只能从头到尾遍历，题目却要从尾到头打印，这是典型的“后进先出”，所以想到可以用栈来实现。\n\n### 思路\n有两种解题方式，一种是循环，另一种是递归。\n- 循环：首先遍历链表将各节点入栈，然后再遍历出栈即可。\n- 递归：递归的本质是栈结构。我们每访问到一个节点的时候，先递归输出它后面的节点，再输出该节点自身，这样链表的输出结果就反过来了。\n\n虽然递归的代码更简洁，但是当链表很长的时候，就会导致函数调用的层级很深，从而可能导致函数调用栈溢出。\n\n### 原文代码(C/C++)\n```\n// 链表定义如下:\nstruct ListNode\n{\n    int m_nValue;\n    ListNode* m_pNext;\n}\n```\nhttps://github.com/zhedahht/CodingInterviewChinese2/blob/master/06_PrintListInReversedOrder/PrintListInReversedOrder.cpp\n\n\n### 个人编写代码(C#)\n```\n// 链表定义如下：\npublic class ListNode\n{\n    public int val;\n    public ListNode next;\n    public ListNode(int x) { val = x; }\n}\n```\n\n#### 循环解法\nC#的Stack类型存在ToArray的方法，相当于替我们封装实现了遍历出栈并生成数组的操作。\n```\npublic int[] ReversePrintIteration(ListNode head)\n{\n    Stack<int> stack = new Stack<int>();\n    while(head != null)\n    {\n        stack.Push(head.val);\n        head = head.next;\n    }\n\n    return stack.ToArray();\n}\n```\n由于力扣题库要求返回int数组，所以我们也可以利用数组使用下标直接读取的特性，在第一次遍历的时候不需要将节点的值入栈，只需要获得节点数并创建对应长度的数组，最后对数组从后往前遍历的同时赋上链表第二次遍历的值。\n```\npublic int[] ReversePrintIteration2(ListNode head)\n{\n    int count = 0;\n    ListNode p = head;\n    while (p != null)\n    {\n        ++count;\n        p = p.next;\n    }\n\n    p = head;\n    int[] result = new int[count];\n    for(int i = count-1; i >= 0; --i, p = p.next)\n    {\n        result[i] = p.val;\n    }\n\n    return result;\n}\n```\n\n#### 递归解法\n由于力扣题库要求返回int数组而非直接打印，我们需要声明并初始化一个全局int数组变量。\n```\npublic List<int> result = new List<int>();\n\npublic int[] ReversePrintRecursion(ListNode head)\n{\n    ReversePrintRecursionList(head);\n\n    return result.ToArray();\n}\n\nprivate void ReversePrintRecursionList(ListNode head)\n{\n    if (head == null)\n        return;\n\n    ReversePrintRecursionList(head.next);\n    result.Add(head.val);\n}\n```\n","source":"_posts/coding-interview/coding-interview-6.md","raw":"---\ntitle: 剑指Offer面试题6：从尾到头打印链表\ndate: 2022-02-20 21:28:00\ncategories: Coding Interview Edition 2\ntags:\n---\n\n**链表**是由指针把若干个节点连接而成的链状结构，它是一种动态数据结构，在创建之时无须知道长度。当插入一个节点的时候，只需要为新节点分配内存然后调整指针的指向来确保新节点被链接到了链表中。可以理解为“按需分配”，空间利用率较高。\n\n<!--more-->\n\n|输入一个链表的头节点，从尾到头反过来打印出每个节点的值。</br>LeetCode力扣链接：[https://leetcode-cn.com/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof/]|\n|---|\n\n由于这里涉及的链表是单向的，只能从头到尾遍历，题目却要从尾到头打印，这是典型的“后进先出”，所以想到可以用栈来实现。\n\n### 思路\n有两种解题方式，一种是循环，另一种是递归。\n- 循环：首先遍历链表将各节点入栈，然后再遍历出栈即可。\n- 递归：递归的本质是栈结构。我们每访问到一个节点的时候，先递归输出它后面的节点，再输出该节点自身，这样链表的输出结果就反过来了。\n\n虽然递归的代码更简洁，但是当链表很长的时候，就会导致函数调用的层级很深，从而可能导致函数调用栈溢出。\n\n### 原文代码(C/C++)\n```\n// 链表定义如下:\nstruct ListNode\n{\n    int m_nValue;\n    ListNode* m_pNext;\n}\n```\nhttps://github.com/zhedahht/CodingInterviewChinese2/blob/master/06_PrintListInReversedOrder/PrintListInReversedOrder.cpp\n\n\n### 个人编写代码(C#)\n```\n// 链表定义如下：\npublic class ListNode\n{\n    public int val;\n    public ListNode next;\n    public ListNode(int x) { val = x; }\n}\n```\n\n#### 循环解法\nC#的Stack类型存在ToArray的方法，相当于替我们封装实现了遍历出栈并生成数组的操作。\n```\npublic int[] ReversePrintIteration(ListNode head)\n{\n    Stack<int> stack = new Stack<int>();\n    while(head != null)\n    {\n        stack.Push(head.val);\n        head = head.next;\n    }\n\n    return stack.ToArray();\n}\n```\n由于力扣题库要求返回int数组，所以我们也可以利用数组使用下标直接读取的特性，在第一次遍历的时候不需要将节点的值入栈，只需要获得节点数并创建对应长度的数组，最后对数组从后往前遍历的同时赋上链表第二次遍历的值。\n```\npublic int[] ReversePrintIteration2(ListNode head)\n{\n    int count = 0;\n    ListNode p = head;\n    while (p != null)\n    {\n        ++count;\n        p = p.next;\n    }\n\n    p = head;\n    int[] result = new int[count];\n    for(int i = count-1; i >= 0; --i, p = p.next)\n    {\n        result[i] = p.val;\n    }\n\n    return result;\n}\n```\n\n#### 递归解法\n由于力扣题库要求返回int数组而非直接打印，我们需要声明并初始化一个全局int数组变量。\n```\npublic List<int> result = new List<int>();\n\npublic int[] ReversePrintRecursion(ListNode head)\n{\n    ReversePrintRecursionList(head);\n\n    return result.ToArray();\n}\n\nprivate void ReversePrintRecursionList(ListNode head)\n{\n    if (head == null)\n        return;\n\n    ReversePrintRecursionList(head.next);\n    result.Add(head.val);\n}\n```\n","slug":"coding-interview/coding-interview-6","published":1,"updated":"2022-02-20T15:00:26.394Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckzvedpm40000vgup0dj84vmi","content":"<p><strong>链表</strong>是由指针把若干个节点连接而成的链状结构，它是一种动态数据结构，在创建之时无须知道长度。当插入一个节点的时候，只需要为新节点分配内存然后调整指针的指向来确保新节点被链接到了链表中。可以理解为“按需分配”，空间利用率较高。</p>\n<span id=\"more\"></span>\n\n<table>\n<thead>\n<tr>\n<th>输入一个链表的头节点，从尾到头反过来打印出每个节点的值。</br>LeetCode力扣链接：[<a href=\"https://leetcode-cn.com/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof/]\">https://leetcode-cn.com/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof/]</a></th>\n</tr>\n</thead>\n</table>\n<p>由于这里涉及的链表是单向的，只能从头到尾遍历，题目却要从尾到头打印，这是典型的“后进先出”，所以想到可以用栈来实现。</p>\n<h3 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h3><p>有两种解题方式，一种是循环，另一种是递归。</p>\n<ul>\n<li>循环：首先遍历链表将各节点入栈，然后再遍历出栈即可。</li>\n<li>递归：递归的本质是栈结构。我们每访问到一个节点的时候，先递归输出它后面的节点，再输出该节点自身，这样链表的输出结果就反过来了。</li>\n</ul>\n<p>虽然递归的代码更简洁，但是当链表很长的时候，就会导致函数调用的层级很深，从而可能导致函数调用栈溢出。</p>\n<h3 id=\"原文代码-C-C\"><a href=\"#原文代码-C-C\" class=\"headerlink\" title=\"原文代码(C/C++)\"></a>原文代码(C/C++)</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 链表定义如下:</span><br><span class=\"line\">struct ListNode</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    int m_nValue;</span><br><span class=\"line\">    ListNode* m_pNext;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><a href=\"https://github.com/zhedahht/CodingInterviewChinese2/blob/master/06_PrintListInReversedOrder/PrintListInReversedOrder.cpp\">https://github.com/zhedahht/CodingInterviewChinese2/blob/master/06_PrintListInReversedOrder/PrintListInReversedOrder.cpp</a></p>\n<h3 id=\"个人编写代码-C\"><a href=\"#个人编写代码-C\" class=\"headerlink\" title=\"个人编写代码(C#)\"></a>个人编写代码(C#)</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 链表定义如下：</span><br><span class=\"line\">public class ListNode</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    public int val;</span><br><span class=\"line\">    public ListNode next;</span><br><span class=\"line\">    public ListNode(int x) &#123; val = x; &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"循环解法\"><a href=\"#循环解法\" class=\"headerlink\" title=\"循环解法\"></a>循环解法</h4><p>C#的Stack类型存在ToArray的方法，相当于替我们封装实现了遍历出栈并生成数组的操作。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public int[] ReversePrintIteration(ListNode head)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    Stack&lt;int&gt; stack = new Stack&lt;int&gt;();</span><br><span class=\"line\">    while(head != null)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        stack.Push(head.val);</span><br><span class=\"line\">        head = head.next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    return stack.ToArray();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>由于力扣题库要求返回int数组，所以我们也可以利用数组使用下标直接读取的特性，在第一次遍历的时候不需要将节点的值入栈，只需要获得节点数并创建对应长度的数组，最后对数组从后往前遍历的同时赋上链表第二次遍历的值。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public int[] ReversePrintIteration2(ListNode head)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    int count = 0;</span><br><span class=\"line\">    ListNode p = head;</span><br><span class=\"line\">    while (p != null)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        ++count;</span><br><span class=\"line\">        p = p.next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    p = head;</span><br><span class=\"line\">    int[] result = new int[count];</span><br><span class=\"line\">    for(int i = count-1; i &gt;= 0; --i, p = p.next)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        result[i] = p.val;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    return result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"递归解法\"><a href=\"#递归解法\" class=\"headerlink\" title=\"递归解法\"></a>递归解法</h4><p>由于力扣题库要求返回int数组而非直接打印，我们需要声明并初始化一个全局int数组变量。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public List&lt;int&gt; result = new List&lt;int&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">public int[] ReversePrintRecursion(ListNode head)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    ReversePrintRecursionList(head);</span><br><span class=\"line\"></span><br><span class=\"line\">    return result.ToArray();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">private void ReversePrintRecursionList(ListNode head)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    if (head == null)</span><br><span class=\"line\">        return;</span><br><span class=\"line\"></span><br><span class=\"line\">    ReversePrintRecursionList(head.next);</span><br><span class=\"line\">    result.Add(head.val);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<p><strong>链表</strong>是由指针把若干个节点连接而成的链状结构，它是一种动态数据结构，在创建之时无须知道长度。当插入一个节点的时候，只需要为新节点分配内存然后调整指针的指向来确保新节点被链接到了链表中。可以理解为“按需分配”，空间利用率较高。</p>","more":"<table>\n<thead>\n<tr>\n<th>输入一个链表的头节点，从尾到头反过来打印出每个节点的值。</br>LeetCode力扣链接：[<a href=\"https://leetcode-cn.com/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof/]\">https://leetcode-cn.com/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof/]</a></th>\n</tr>\n</thead>\n</table>\n<p>由于这里涉及的链表是单向的，只能从头到尾遍历，题目却要从尾到头打印，这是典型的“后进先出”，所以想到可以用栈来实现。</p>\n<h3 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h3><p>有两种解题方式，一种是循环，另一种是递归。</p>\n<ul>\n<li>循环：首先遍历链表将各节点入栈，然后再遍历出栈即可。</li>\n<li>递归：递归的本质是栈结构。我们每访问到一个节点的时候，先递归输出它后面的节点，再输出该节点自身，这样链表的输出结果就反过来了。</li>\n</ul>\n<p>虽然递归的代码更简洁，但是当链表很长的时候，就会导致函数调用的层级很深，从而可能导致函数调用栈溢出。</p>\n<h3 id=\"原文代码-C-C\"><a href=\"#原文代码-C-C\" class=\"headerlink\" title=\"原文代码(C/C++)\"></a>原文代码(C/C++)</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 链表定义如下:</span><br><span class=\"line\">struct ListNode</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    int m_nValue;</span><br><span class=\"line\">    ListNode* m_pNext;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><a href=\"https://github.com/zhedahht/CodingInterviewChinese2/blob/master/06_PrintListInReversedOrder/PrintListInReversedOrder.cpp\">https://github.com/zhedahht/CodingInterviewChinese2/blob/master/06_PrintListInReversedOrder/PrintListInReversedOrder.cpp</a></p>\n<h3 id=\"个人编写代码-C\"><a href=\"#个人编写代码-C\" class=\"headerlink\" title=\"个人编写代码(C#)\"></a>个人编写代码(C#)</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 链表定义如下：</span><br><span class=\"line\">public class ListNode</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    public int val;</span><br><span class=\"line\">    public ListNode next;</span><br><span class=\"line\">    public ListNode(int x) &#123; val = x; &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"循环解法\"><a href=\"#循环解法\" class=\"headerlink\" title=\"循环解法\"></a>循环解法</h4><p>C#的Stack类型存在ToArray的方法，相当于替我们封装实现了遍历出栈并生成数组的操作。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public int[] ReversePrintIteration(ListNode head)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    Stack&lt;int&gt; stack = new Stack&lt;int&gt;();</span><br><span class=\"line\">    while(head != null)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        stack.Push(head.val);</span><br><span class=\"line\">        head = head.next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    return stack.ToArray();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>由于力扣题库要求返回int数组，所以我们也可以利用数组使用下标直接读取的特性，在第一次遍历的时候不需要将节点的值入栈，只需要获得节点数并创建对应长度的数组，最后对数组从后往前遍历的同时赋上链表第二次遍历的值。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public int[] ReversePrintIteration2(ListNode head)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    int count = 0;</span><br><span class=\"line\">    ListNode p = head;</span><br><span class=\"line\">    while (p != null)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        ++count;</span><br><span class=\"line\">        p = p.next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    p = head;</span><br><span class=\"line\">    int[] result = new int[count];</span><br><span class=\"line\">    for(int i = count-1; i &gt;= 0; --i, p = p.next)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        result[i] = p.val;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    return result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"递归解法\"><a href=\"#递归解法\" class=\"headerlink\" title=\"递归解法\"></a>递归解法</h4><p>由于力扣题库要求返回int数组而非直接打印，我们需要声明并初始化一个全局int数组变量。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public List&lt;int&gt; result = new List&lt;int&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">public int[] ReversePrintRecursion(ListNode head)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    ReversePrintRecursionList(head);</span><br><span class=\"line\"></span><br><span class=\"line\">    return result.ToArray();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">private void ReversePrintRecursionList(ListNode head)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    if (head == null)</span><br><span class=\"line\">        return;</span><br><span class=\"line\"></span><br><span class=\"line\">    ReversePrintRecursionList(head.next);</span><br><span class=\"line\">    result.Add(head.val);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"}],"PostAsset":[{"_id":"source/_posts/coding-interview/coding-interview-5/replace-space.jpg","slug":"replace-space.jpg","post":"ckzuxevjb0000sgup5hfd2bnf","modified":0,"renderable":0},{"_id":"source/_posts/android-reverse-analytics/compilation-assembly.png","slug":"compilation-assembly.png","post":"ckztkpexg0000xoupcgvj81wr","modified":0,"renderable":0}],"PostCategory":[{"post_id":"ckzsrf1410002zcup14cifb25","category_id":"ckzst7lfm0005xgup6edudx94","_id":"ckzst7lfn0006xgup8jk8599g"},{"post_id":"ckzsrfl500000u8up3x3bg07e","category_id":"ckztiaa9y0001l4up65cdfv9s","_id":"ckztiaaa10002l4upfc6jhpnm"},{"post_id":"ckztkpexg0000xoupcgvj81wr","category_id":"ckzsprryx000yjcuphpkj7ir4","_id":"ckztkpexn0006xoup42zzgqt5"},{"post_id":"ckztkpexk0001xoup674e1919","category_id":"ckzsripwi0006u8upe7qlc1uy","_id":"ckztkpexo0008xoupb1mq1oba"},{"post_id":"ckztkpexl0003xoup8pm275oy","category_id":"ckzst6qjg0000xgup6o5c48yw","_id":"ckztkpexp000bxoupbhnv2ss7"},{"post_id":"ckztkpexm0005xoupcbx12fdd","category_id":"ckzss6n2e000hu8upbwr5bjr7","_id":"ckztkpexq000cxoupeq59do0g"},{"post_id":"ckztkpexp000axoup2ai441au","category_id":"ckzss6n2e000hu8upbwr5bjr7","_id":"ckztkpext000gxoup6xjj3v13"},{"post_id":"ckztkpexq000exoup5s0wgf73","category_id":"ckztkpext000hxoup7y9wbkxr","_id":"ckztkpexx000ixoupfrw756nb"},{"post_id":"ckztkpexr000fxoup0p0adiym","category_id":"ckztkpext000hxoup7y9wbkxr","_id":"ckztkxiuo0000j8up1b599f5n"},{"post_id":"ckztmbsra0000mgup3vcpfmky","category_id":"ckztmbsre0001mgupcigsb2p0","_id":"ckztmbsrj0002mgupepdybiw1"},{"post_id":"ckzu6odil0000xoupco5be8l6","category_id":"ckztkpext000hxoup7y9wbkxr","_id":"ckzu7y06g0000cgup6npc2j6x"},{"post_id":"ckzuxevjb0000sgup5hfd2bnf","category_id":"ckztkpext000hxoup7y9wbkxr","_id":"ckzuxevjg0001sgup9mypfc3g"},{"post_id":"ckzvedpm40000vgup0dj84vmi","category_id":"ckztkpext000hxoup7y9wbkxr","_id":"ckzvedpm70001vgupa4wfgonf"}],"PostTag":[{"post_id":"ckzsrfl500000u8up3x3bg07e","tag_id":"ckzsnzubj0001jcupf8pya4p8","_id":"ckzsrfl520001u8up6i3deq2k"},{"post_id":"ckzsrf1410002zcup14cifb25","tag_id":"ckzst7uka0007xgup04w3hrw6","_id":"ckzst7ukb0008xgupar53dk1e"},{"post_id":"ckztkpexg0000xoupcgvj81wr","tag_id":"ckzsqhfph0013jcuphzoj1p69","_id":"ckztkpexl0002xoupay8vdd97"},{"post_id":"ckztkpexk0001xoup674e1919","tag_id":"ckzsriik50004u8up10arhy2g","_id":"ckztkpexm0004xoupdlgthpg8"},{"post_id":"ckztkpexl0003xoup8pm275oy","tag_id":"ckzsob7gi0006jcup856o1keb","_id":"ckztkpexn0007xoup0hin8noi"},{"post_id":"ckztkpexm0005xoupcbx12fdd","tag_id":"ckzss6fdm000fu8upaqft9mms","_id":"ckztkpexp0009xoup1z79c34m"},{"post_id":"ckztkpexp000axoup2ai441au","tag_id":"ckzsoeu6y000cjcupfufb100v","_id":"ckztkpexq000dxoupe8519duc"},{"post_id":"ckzu6odil0000xoupco5be8l6","tag_id":"ckzu7ybof0003cgup7n0d4der","_id":"ckzu7ybog0004cgup3nfg3ce6"},{"post_id":"ckztkpexq000exoup5s0wgf73","tag_id":"ckzu7ybof0003cgup7n0d4der","_id":"ckzu7ygeh0005cgup6bn705k0"}],"Tag":[{"name":"Blog","_id":"ckzsnzubj0001jcupf8pya4p8"},{"name":"Computer Network","_id":"ckzsob7gi0006jcup856o1keb"},{"name":"Linux","_id":"ckzsoeu6y000cjcupfufb100v"},{"name":"Test","_id":"ckzsoh31y000gjcup6me55vnx"},{"name":"Android, Security","_id":"ckzspljll000qjcupba715qaj"},{"name":"Android; Security","_id":"ckzspm9wu000sjcupagvj6gyt"},{"name":"Android Security","_id":"ckzspmet8000ujcup3ram3f6o"},{"name":"Security","_id":"ckzsqhfph0013jcuphzoj1p69"},{"name":"Web","_id":"ckzsriik50004u8up10arhy2g"},{"name":"Git","_id":"ckzss6fdm000fu8upaqft9mms"},{"name":"Automation Test","_id":"ckzst7uka0007xgup04w3hrw6"},{"name":"2D Array","_id":"ckzu7ya840001cgup17uyf1ua"},{"name":"Array","_id":"ckzu7ybof0003cgup7n0d4der"}]}}